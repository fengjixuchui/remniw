%{
#include "AsmBuilder.h"
#define DEBUG_TYPE "remniw-asmbuilderhelper"
%}

# TODO: autogen from llvm/include/llvm/IR/Instruction.def

%term BRG_UNDEF         =  0

# Terminator Instructions
%term BRG_RET           =  1
%term BRG_BR            =  2
%term BRG_SWITCH        =  3
%term BRG_INDIRECTBR    =  4
%term BRG_INVOKE        =  5
%term BRG_RESUME        =  6
%term BRG_UNREACHABLE   =  7
%term BRG_CLEANUPRET    =  8
%term BRG_CATCHRET      =  9
%term BRG_CATCHSWITCH   = 10
%term BRG_CALLBR        = 11

# Standard unary operators
%term BRG_FNEG          = 12

# Standard binary operators
%term BRG_ADD  = 13
%term BRG_FADD = 14
%term BRG_SUB  = 15
%term BRG_FSUB = 16
%term BRG_MUL  = 17
%term BRG_FMUL = 18
%term BRG_UDIV = 19
%term BRG_SDIV = 20
%term BRG_FDIV = 21
%term BRG_UREM = 22
%term BRG_SREM = 23
%term BRG_FREM = 24

# Logical operators (integer operands)
%term BRG_SHL  = 25
%term BRG_LSHR = 26
%term BRG_ASHR = 27
%term BRG_AND  = 28
%term BRG_OR   = 29
%term BRG_XOR  = 30

# Memory operators
%term BRG_ALLOCA        = 31
%term BRG_LOAD          = 32
%term BRG_STORE         = 33
%term BRG_GETELEMENTPTR = 34
%term BRG_FENCE         = 35
%term BRG_ATOMICCMPXCHG = 36
%term BRG_ATOMICRMW     = 37

# Cast operators
%term BRG_TRUNC         = 38
%term BRG_ZEXT          = 39
%term BRG_SEXT          = 40
%term BRG_FPTOUI        = 41
%term BRG_FPTOSI        = 42
%term BRG_UITOFP        = 43
%term BRG_SITOFP        = 44
%term BRG_FPTRUNC       = 45
%term BRG_FPEXT         = 46
%term BRG_PTRTOINT      = 47
%term BRG_INTTOPTR      = 48
%term BRG_BITCAST       = 49
%term BRG_ADDRSPACECAST = 50

# FUNCLETPAD
%term BRG_CLEANUPPAD    = 51
%term BRG_CATCHPAD      = 52

# Other operators
%term BRG_ICMP              = 53
%term BRG_FCMP              = 54
%term BRG_PHI               = 55
%term BRG_CALL              = 56
%term BRG_SELECT            = 57
%term BRG_USEROP1           = 58
%term BRG_USEROP2           = 59
%term BRG_VAARG             = 60
%term BRG_EXTRACTELEMENT    = 61
%term BRG_INSERTELEMENT     = 62
%term BRG_SHUFFLEVECTOR     = 63
%term BRG_EXTRACTVALUE      = 64
%term BRG_INSERTVALUE       = 65
%term BRG_LANDINGPAD        = 66
%term BRG_FREEZE            = 67

%term BRG_CONST            = 68
%term BRG_LABEL            = 69
%term BRG_ARGS             = 70
%term BRG_REG              = 71

%declare<void> stmt<remniw::AsmBuilderPtr Builder>;
%declare<void> reg<remniw::AsmBuilderPtr Builder>;
%declare<void> imm<remniw::AsmBuilderPtr Builder>;
%declare<void> mem<remniw::AsmBuilderPtr Builder>;
%declare<void> label<remniw::AsmBuilderPtr Builder>;
%declare<void> cond<remniw::AsmBuilderPtr Builder>;
%declare<void> arg<remniw::AsmBuilderPtr Builder, unsigned argNo>;
%declare<void> args<remniw::AsmBuilderPtr Builder, unsigned argNo>;

%%

label: BRG_LABEL { $cost[0].cost = 0; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "label: BRG_LABEL\n";);
};

imm: BRG_CONST { $cost[0].cost = 0; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "imm: BRG_CONST\n";);
};

reg: BRG_REG { $cost[0].cost = 0; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_REG\n";);
};

mem: BRG_ALLOCA(imm) { $cost[0].cost = 0; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "mem: BRG_ALLOCA(imm)\n";);
};

reg: BRG_LOAD(mem) { $cost[0].cost = $cost[2].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_LOAD(mem)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    uint32_t VirtReg = remniw::Register::createVirtReg();
    $0->setReg(VirtReg);
    auto Src = remniw::AsmOperand::createMem($2->getMemDisp(),$2->getMemBaseReg(),
                                             $2->getMemIndexReg(), $2->getMemScale());
    auto Dst = remniw::AsmOperand::createReg(VirtReg);
    Builder->createMov(std::move(Src), std::move(Dst));
};

reg: BRG_LOAD(reg) { $cost[0].cost = $cost[2].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_LOAD(reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    uint32_t VirtReg = remniw::Register::createVirtReg();
    $0->setReg(VirtReg);
    auto Src = remniw::AsmOperand::createMem(0, $2->getReg());
    auto Dst = remniw::AsmOperand::createReg(VirtReg);
    Builder->createMov(std::move(Src), std::move(Dst));
};

stmt: reg { $cost[0].cost = $cost[1].cost; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "stmt: reg\n";);
    // if ($0->isActionExecuted())
    //     return;
    // $0->setActionExecuted();
    $action[1](Builder);
};

stmt: BRG_RET(reg) { $cost[0].cost = $cost[2].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "stmt: BRG_RET(reg)\n";);
    $action[2](Builder);
    auto Src = remniw::AsmOperand::createReg($2->getReg());
    auto Dst = remniw::AsmOperand::createReg(remniw::Register::RAX);
    Builder->createMov(std::move(Src), std::move(Dst));
};

stmt: BRG_RET(imm) { $cost[0].cost = $cost[2].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "stmt: BRG_RET(imm)\n";);
    $action[2](Builder);
    auto Src = remniw::AsmOperand::createImm($2->getImmVal());
    auto Dst = remniw::AsmOperand::createReg(remniw::Register::RAX);
    Builder->createMov(std::move(Src), std::move(Dst));
};

stmt: BRG_STORE(reg, mem) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "stmt: BRG_STORE(reg, mem)\n";);
    $action[2](Builder);
    $action[3](Builder);
    auto Src = remniw::AsmOperand::createReg($2->getReg());
    auto Dst = remniw::AsmOperand::createMem($3->getMemDisp(),$3->getMemBaseReg(),
                                             $3->getMemIndexReg(), $3->getMemScale());
    Builder->createMov(std::move(Src), std::move(Dst));
};

stmt: BRG_STORE(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "stmt: BRG_STORE(reg, reg)\n";);
    $action[2](Builder);
    $action[3](Builder);
    auto Src = remniw::AsmOperand::createReg($2->getReg());
    auto Dst = remniw::AsmOperand::createMem(0, $3->getReg());
    Builder->createMov(std::move(Src), std::move(Dst));
};

stmt: BRG_STORE(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "stmt: BRG_STORE(imm, reg)\n";);
    $action[2](Builder);
    $action[3](Builder);
    auto Src = remniw::AsmOperand::createImm($2->getImmVal());
    auto Dst = remniw::AsmOperand::createMem(0, $3->getReg());
    Builder->createMov(std::move(Src), std::move(Dst));
};

stmt: BRG_STORE(imm, mem) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "stmt: BRG_STORE(imm, mem)\n";);
    $action[2](Builder);
    $action[3](Builder);
    auto Src = remniw::AsmOperand::createImm($2->getImmVal());
    auto Dst = remniw::AsmOperand::createMem($3->getMemDisp(),$3->getMemBaseReg(),
                                             $3->getMemIndexReg(), $3->getMemScale());
    Builder->createMov(std::move(Src), std::move(Dst));
};

stmt: BRG_STORE(mem, mem) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "stmt: BRG_STORE(mem, mem)\n";);
    $action[2](Builder);
    $action[3](Builder);
    uint32_t VirtReg = remniw::Register::createVirtReg();
    $0->setReg(VirtReg);
    auto Src = remniw::AsmOperand::createMem($2->getMemDisp(),$2->getMemBaseReg(),
                                             $2->getMemIndexReg(), $2->getMemScale());
    auto Tmp1 = remniw::AsmOperand::createReg(VirtReg);
    Builder->createLea(std::move(Src), std::move(Tmp1));
    auto Tmp2 = remniw::AsmOperand::createReg(VirtReg);
    auto Dst = remniw::AsmOperand::createMem($3->getMemDisp(),$3->getMemBaseReg(),
                                             $3->getMemIndexReg(), $3->getMemScale());
    Builder->createMov(std::move(Tmp2), std::move(Dst));
};

stmt: BRG_STORE(label, mem) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "stmt: BRG_STORE(label, mem)\n";);
    $action[2](Builder);
    $action[3](Builder);
    auto Src = remniw::AsmOperand::createLabel($2->getLabel());
    uint32_t TmpVirtReg = remniw::Register::createVirtReg();
    auto Tmp1 = remniw::AsmOperand::createReg(TmpVirtReg);
    Builder->createLea(std::move(Src), std::move(Tmp1));
    auto Tmp2 = remniw::AsmOperand::createReg(TmpVirtReg);
    auto Dst = remniw::AsmOperand::createMem($3->getMemDisp(),$3->getMemBaseReg(),
                                             $3->getMemIndexReg(), $3->getMemScale());
    Builder->createMov(std::move(Tmp2), std::move(Dst));
};

cond: BRG_ICMP(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "cond: BRG_ICMP(reg, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    auto Src = remniw::AsmOperand::createReg($3->getReg());
    auto Dst = remniw::AsmOperand::createReg($2->getReg());
    Builder->createCmp(std::move(Src), std::move(Dst));
};

cond: BRG_ICMP(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "cond: BRG_ICMP(reg, imm)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    auto Src = remniw::AsmOperand::createImm($3->getImmVal());
    auto Dst = remniw::AsmOperand::createReg($2->getReg());
    Builder->createCmp(std::move(Src), std::move(Dst));
};

cond: BRG_ICMP(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "cond: BRG_ICMP(imm, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    auto MovSrc = remniw::AsmOperand::createImm($2->getImmVal());
    std::unique_ptr<remniw::AsmOperand> Dst = nullptr;
    Dst = remniw::AsmOperand::createReg(remniw::Register::createVirtReg());
    Builder->createMov(std::move(MovSrc), std::move(Dst));
    auto CmpSrc = remniw::AsmOperand::createReg($3->getReg());
    Dst = remniw::AsmOperand::createReg(remniw::Register::createVirtReg());
    Builder->createCmp(std::move(CmpSrc), std::move(Dst));
};

# Conditional Branch
stmt: BRG_BR(cond, label, label)
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "stmt: BRG_BR(cond, label, label)\n";);
    $action[2](Builder);
    remniw::AsmJmpInst::JmpKindTy JmpTrue, JmpFalse;
    auto *CI = llvm::cast<llvm::CmpInst>($2->getInstruction());
    switch (CI->getPredicate()) {
    case llvm::CmpInst::Predicate::ICMP_EQ:
        JmpTrue = remniw::AsmJmpInst::JmpKindTy::Je;
        JmpFalse = remniw::AsmJmpInst::JmpKindTy::Jne;
        break;
    case llvm::CmpInst::Predicate::ICMP_NE:
        JmpTrue = remniw::AsmJmpInst::JmpKindTy::Jne;
        JmpFalse = remniw::AsmJmpInst::JmpKindTy::Je;
        break;
    case llvm::CmpInst::Predicate::ICMP_SGT:
        JmpTrue = remniw::AsmJmpInst::JmpKindTy::Jg;
        JmpFalse = remniw::AsmJmpInst::JmpKindTy::Jle;
        break;
    default:
        llvm_unreachable("unexpected CmpInst!\n");
    }
    auto *BI = llvm::cast<llvm::BranchInst>($1->getInstruction());
    llvm::BasicBlock* NextBB = BI->getParent()->getNextNode();
    if (NextBB == BI->getSuccessor(0)) {
        Builder->createJmp(JmpFalse, remniw::AsmOperand::createLabel($4->getLabel()));
    }
    else if (NextBB == BI->getSuccessor(1)) {
        Builder->createJmp(JmpTrue, remniw::AsmOperand::createLabel($3->getLabel()));
    }
    else {
        Builder->createJmp(JmpTrue, remniw::AsmOperand::createLabel($3->getLabel()));
        Builder->createJmp(JmpFalse, remniw::AsmOperand::createLabel($4->getLabel()));
    }
};

# Unconditional Branch
stmt: BRG_BR(label, BRG_UNDEF, BRG_UNDEF) { $cost[0].cost = $cost[2].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "stmt: BRG_BR(label, BRG_UNDEF, BRG_UNDEF)\n";);
    auto *BI = llvm::cast<llvm::BranchInst>($1->getInstruction());
    llvm::BasicBlock* NextBB = BI->getParent()->getNextNode();
    if (NextBB != BI->getSuccessor(0)) {
        Builder->createJmp(remniw::AsmJmpInst::JmpKindTy::Jmp,
                           remniw::AsmOperand::createLabel($2->getLabel()));
    }
};

reg: BRG_ADD(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_ADD(reg, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    auto Src = remniw::AsmOperand::createReg($2->getReg());
    auto Dst = remniw::AsmOperand::createReg($3->getReg());
    Builder->createAdd(std::move(Src), std::move(Dst));
    $0->setReg($3->getReg());
};

reg: BRG_ADD(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_ADD(reg, imm)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    auto Src = remniw::AsmOperand::createImm($3->getImmVal());
    auto Dst = remniw::AsmOperand::createReg($2->getReg());
    Builder->createAdd(std::move(Src), std::move(Dst));
    $0->setReg($2->getReg());
};

reg: BRG_ADD(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_ADD(imm, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    auto Src = remniw::AsmOperand::createImm($2->getImmVal());
    auto Dst = remniw::AsmOperand::createReg($3->getReg());
    Builder->createAdd(std::move(Src), std::move(Dst));
    $0->setReg($3->getReg());
};

reg: BRG_ADD(imm, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_ADD(imm, imm)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    llvm_unreachable("unexpected action: reg: BRG_ADD(imm, imm)!\n");
};

reg: BRG_SUB(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_SUB(reg, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    auto Src = remniw::AsmOperand::createReg($3->getReg());
    auto Dst = remniw::AsmOperand::createReg($2->getReg());
    Builder->createSub(std::move(Src), std::move(Dst));
    $0->setReg($2->getReg());
};

reg: BRG_SUB(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_SUB(reg, imm)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    auto Src = remniw::AsmOperand::createImm($3->getImmVal());
    auto Dst = remniw::AsmOperand::createReg($2->getReg());
    Builder->createSub(std::move(Src), std::move(Dst));
    $0->setReg($2->getReg());
};

reg: BRG_SUB(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_SUB(imm, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    $0->setReg(remniw::Register::createVirtReg());
    auto Src1 = remniw::AsmOperand::createImm($2->getImmVal());
    auto Dst1 = remniw::AsmOperand::createReg($0->getReg());
    Builder->createMov(std::move(Src1), std::move(Dst1));
    auto Src2 = remniw::AsmOperand::createReg($3->getReg());
    auto Dst2 = remniw::AsmOperand::createReg($0->getReg());
    Builder->createSub(std::move(Src2), std::move(Dst2));
};

reg: BRG_SUB(imm, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_SUB(imm, imm)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    llvm_unreachable("unexpected action reg: BRG_SUB(imm, imm)\n");
};

reg: BRG_MUL(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_MUL(reg, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    auto Src = remniw::AsmOperand::createReg($2->getReg());
    auto Dst = remniw::AsmOperand::createReg($3->getReg());
    Builder->createImul(std::move(Src), std::move(Dst));
    $0->setReg($3->getReg());
};

reg: BRG_MUL(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_MUL(reg, imm)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    auto Src = remniw::AsmOperand::createImm($3->getImmVal());
    auto Dst = remniw::AsmOperand::createReg($2->getReg());
    Builder->createImul(std::move(Src), std::move(Dst));
    $0->setReg($2->getReg());
};

reg: BRG_MUL(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_MUL(imm, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    auto Src = remniw::AsmOperand::createImm($2->getImmVal());
    auto Dst = remniw::AsmOperand::createReg($3->getReg());
    Builder->createImul(std::move(Src), std::move(Dst));
    $0->setReg($3->getReg());
};

reg: BRG_MUL(imm, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_MUL(imm, imm)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    llvm_unreachable("unexpected action reg: BRG_MUL(imm, imm)\n");
};

reg: BRG_SDIV(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_SDIV(reg, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    auto Tmp = remniw::AsmOperand::createReg(remniw::Register::RAX);
    auto MovSrc = remniw::AsmOperand::createReg($2->getReg());
    Builder->createMov(std::move(MovSrc), std::move(Tmp));
    Builder->createCqto();
    auto IdivDst = remniw::AsmOperand::createReg($3->getReg());
    Builder->createIdiv(std::move(IdivDst));
    $0->setReg(remniw::Register::RAX);
};

reg: BRG_SDIV(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_SDIV(reg, imm)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    $0->setReg(remniw::Register::createVirtReg());
    Builder->createMov(remniw::AsmOperand::createReg($2->getReg()), remniw::AsmOperand::createReg(remniw::Register::RAX));
    Builder->createCqto();
    Builder->createMov(remniw::AsmOperand::createImm($3->getImmVal()), remniw::AsmOperand::createReg($0->getReg()));
    Builder->createIdiv(remniw::AsmOperand::createReg($0->getReg()));
    Builder->createMov(remniw::AsmOperand::createReg(remniw::Register::RAX), remniw::AsmOperand::createReg($0->getReg()));
};

reg: BRG_SDIV(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_SDIV(imm, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    Builder->createMov(remniw::AsmOperand::createImm($2->getImmVal()), remniw::AsmOperand::createReg(remniw::Register::RAX));
    Builder->createCqto();
    Builder->createIdiv(remniw::AsmOperand::createReg($3->getReg()));
    $0->setReg(remniw::Register::RAX);
};

reg: BRG_SDIV(imm, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_SDIV(imm, reg)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder);
    llvm_unreachable("unexpected action reg: BRG_SDIV(imm, imm)!\n");
};

arg: reg { $cost[0].cost = $cost[1].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "arg: reg\n";);
    $action[1](Builder);
    if (argNo < 6) {
        Builder->createMov(remniw::AsmOperand::createReg($1->getReg()),
            remniw::AsmOperand::createReg(remniw::Register::ArgRegs[argNo]));
    } else {
        Builder->createMov(remniw::AsmOperand::createReg($1->getReg()),
            remniw::AsmOperand::createMem(8 * (argNo - 6), remniw::Register::RSP));
    }
};

arg: imm { $cost[0].cost = $cost[1].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "arg: imm\n";);
    $action[1](Builder);
    if (argNo < 6) {
        Builder->createMov(remniw::AsmOperand::createImm($1->getImmVal()),
            remniw::AsmOperand::createReg(remniw::Register::ArgRegs[argNo]));
    } else {
        Builder->createMov(remniw::AsmOperand::createImm($1->getImmVal()),
            remniw::AsmOperand::createMem(8 * (argNo - 6), remniw::Register::RSP));
    }
};

arg: mem { $cost[0].cost = $cost[1].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "arg: mem\n";);
    $action[1](Builder);
    if (argNo < 6) {
        Builder->createLea(remniw::AsmOperand::createMem($1->getMemDisp(),
                                                         $1->getMemBaseReg(),
                                                         $1->getMemIndexReg(),
                                                         $1->getMemScale()),
            remniw::AsmOperand::createReg(remniw::Register::ArgRegs[argNo]));
    } else {
        Builder->createMov(remniw::AsmOperand::createMem($1->getMemDisp(),
                                                         $1->getMemBaseReg(),
                                                         $1->getMemIndexReg(),
                                                         $1->getMemScale()),
            remniw::AsmOperand::createMem(8 * (argNo - 6), remniw::Register::RSP));
    }
};

arg: label { $cost[0].cost = $cost[1].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "arg: label\n";);
    $action[1](Builder);
    if (argNo < 6) {
        Builder->createLea(remniw::AsmOperand::createLabel($1->getLabel()),
            remniw::AsmOperand::createReg(remniw::Register::ArgRegs[argNo]));
    } else {
        Builder->createLea(remniw::AsmOperand::createLabel($1->getLabel()),
            remniw::AsmOperand::createMem(8 * (argNo - 6), remniw::Register::RSP));
    }
};

args: BRG_ARGS(BRG_UNDEF, BRG_UNDEF) { $cost[0].cost = 0; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "args: BRG_ARGS(BRG_UNDEF, BRG_UNDEF)\n";);
};

args: BRG_ARGS(arg, args)  { $cost[0].cost = $cost[2].cost + $cost[3].cost; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "args: BRG_ARGS(arg, args)\n";);
    $action[2](Builder, argNo);
    $action[3](Builder, argNo+1);
};

# Direct Call
reg: BRG_CALL(label, args) { $cost[0].cost = $cost[2].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_CALL(label, args)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder, 0);
    auto* CB = llvm::cast<llvm::CallBase>($1->getInstruction());
    std::string CalleeName = $2->getLabel()->getName();
    if (CalleeName == "printf" || CalleeName == "scanf") {
        Builder->createXor(remniw::AsmOperand::createReg(remniw::Register::RAX),
                           remniw::AsmOperand::createReg(remniw::Register::RAX));
    }
    Builder->createCall(remniw::AsmOperand::createLabel($2->getLabel()), /*DirectCall*/true);
    $0->setReg(remniw::Register::createVirtReg());
    Builder->createMov(remniw::AsmOperand::createReg(remniw::Register::RAX),
                       remniw::AsmOperand::createReg($0->getReg()));
};

# Indirect Call
reg: BRG_CALL(reg, args) { $cost[0].cost = $cost[2].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_CALL(reg, args)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder, 0);
    Builder->createCall(remniw::AsmOperand::createReg($2->getReg()), /*DirectCall*/false);
    $0->setReg(remniw::Register::createVirtReg());
    Builder->createMov(remniw::AsmOperand::createReg(remniw::Register::RAX),
                       remniw::AsmOperand::createReg($0->getReg()));
};

# Indirect call
reg: BRG_CALL(mem, args) { $cost[0].cost = $cost[2].cost + 1; }
= {
    LLVM_DEBUG(llvm::outs() << "brg action: " << "reg: BRG_CALL(mem, args)\n";);
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](Builder);
    $action[3](Builder, 0);
    Builder->createCall(remniw::AsmOperand::createMem($2->getMemDisp(),
                                                      $2->getMemBaseReg(),
                                                      $2->getMemIndexReg(),
                                                      $2->getMemScale()),
                        /*DirectCall*/false);
    $0->setReg(remniw::Register::createVirtReg());
    Builder->createMov(remniw::AsmOperand::createReg(remniw::Register::RAX),
                       remniw::AsmOperand::createReg($0->getReg()));
};

%%

/* burm_trace - print trace message for matching p */
static void burm_trace(NODEPTR p, int eruleno, COST cost) { }

static void gen(NODEPTR p, remniw::AsmBuilder *Builder) {
    if (burm_label(p) == 0) {
        LLVM_DEBUG(llvm::outs() << "gen: " << "no cover\n";);
    } else {
        stmt_action(p->getState(), Builder);
    }
    burm_free(p->getState());
}


static void printDebugTree(BrgTreeNode *p, int indent=0) {
    if (!p)
        return;
    LLVM_DEBUG({
        if (indent) llvm::outs() << "|";
        int i = 0;
        for (; i < indent - 4; ++i) llvm::outs() << " ";
        if (indent - 4 > 0) llvm::outs() << "|";
        for (; i < indent; ++i) llvm::outs() << "-";
        llvm::outs() << "+ op:" << p->getOp() << ", Kind:" << p->getNodeKindString() << "\n";
        for(auto *kid: p->getKidsVector())
            printDebugTree(kid, (indent+4));
    });
}

namespace remniw {

void AsmBuilder::buildAsmFunction(const BrgFunction *BrgFunc) {
    CurrentFunction = new AsmFunction(BrgFunc->FuncName, BrgFunc->StackSizeInBytes);
    AsmFunctions.push_back(CurrentFunction);

    for (auto* RootNode: BrgFunc->Insts) {
        printDebugTree(RootNode);
        // FIXME: Label Instruction
        if (RootNode->getOp() == /*Label*/69)
            createLabel(AsmOperand::createLabel(RootNode->getLabel()));
        gen(RootNode, this);
    }
}

}  // namespace remniw