%{
#include "ASMCodeGeneratorHelper.h"
%}

# TODO: autogen from llvm/include/llvm/IR/Instruction.def

%term RWIR_UNDEF         =  0

# Terminator Instructions
%term RWIR_RET           =  1
%term RWIR_BR            =  2
%term RWIR_SWITCH        =  3
%term RWIR_INDIRECTBR    =  4
%term RWIR_INVOKE        =  5
%term RWIR_RESUME        =  6
%term RWIR_UNREACHABLE   =  7
%term RWIR_CLEANUPRET    =  8
%term RWIR_CATCHRET      =  9
%term RWIR_CATCHSWITCH   = 10
%term RWIR_CALLBR        = 11

# Standard unary operators
%term RWIR_FNEG          = 12

# Standard binary operators
%term RWIR_ADD  = 13
%term RWIR_FADD = 14
%term RWIR_SUB  = 15
%term RWIR_FSUB = 16
%term RWIR_MUL  = 17
%term RWIR_FMUL = 18
%term RWIR_UDIV = 19
%term RWIR_SDIV = 20
%term RWIR_FDIV = 21
%term RWIR_UREM = 22
%term RWIR_SREM = 23
%term RWIR_FREM = 24

# Logical operators (integer operands)
%term RWIR_SHL  = 25
%term RWIR_LSHR = 26
%term RWIR_ASHR = 27
%term RWIR_AND  = 28
%term RWIR_OR   = 29
%term RWIR_XOR  = 30

# Memory operators
%term RWIR_ALLOCA        = 31
%term RWIR_LOAD          = 32
%term RWIR_STORE         = 33
%term RWIR_GETELEMENTPTR = 34
%term RWIR_FENCE         = 35
%term RWIR_ATOMICCMPXCHG = 36
%term RWIR_ATOMICRMW     = 37

# Cast operators
%term RWIR_TRUNC         = 38
%term RWIR_ZEXT          = 39
%term RWIR_SEXT          = 40
%term RWIR_FPTOUI        = 41
%term RWIR_FPTOSI        = 42
%term RWIR_UITOFP        = 43
%term RWIR_SITOFP        = 44
%term RWIR_FPTRUNC       = 45
%term RWIR_FPEXT         = 46
%term RWIR_PTRTOINT      = 47
%term RWIR_INTTOPTR      = 48
%term RWIR_BITCAST       = 49
%term RWIR_ADDRSPACECAST = 50

# FUNCLETPAD
%term RWIR_CLEANUPPAD    = 51
%term RWIR_CATCHPAD      = 52

# Other operators
%term RWIR_ICMP              = 53
%term RWIR_FCMP              = 54
%term RWIR_PHI               = 55
%term RWIR_CALL              = 56
%term RWIR_SELECT            = 57
%term RWIR_USEROP1           = 58
%term RWIR_USEROP2           = 59
%term RWIR_VAARG             = 60
%term RWIR_EXTRACTELEMENT    = 61
%term RWIR_INSERTELEMENT     = 62
%term RWIR_SHUFFLEVECTOR     = 63
%term RWIR_EXTRACTVALUE      = 64
%term RWIR_INSERTVALUE       = 65
%term RWIR_LANDINGPAD        = 66
%term RWIR_FREEZE            = 67

%term RWIR_CONST            = 68
%term RWIR_LABEL            = 69
%term RWIR_ARGS             = 70
%term RWIR_REG              = 71

%declare<void> stmt<remniw::AsmCodeGeneratorPtr AsmGen>;
%declare<void> reg<remniw::AsmCodeGeneratorPtr AsmGen>;
%declare<void> imm<remniw::AsmCodeGeneratorPtr AsmGen>;
%declare<void> mem<remniw::AsmCodeGeneratorPtr AsmGen>;
%declare<void> label<remniw::AsmCodeGeneratorPtr AsmGen>;
%declare<void> cond<remniw::AsmCodeGeneratorPtr AsmGen>;
%declare<void> arg<remniw::AsmCodeGeneratorPtr AsmGen, unsigned argNo>;
%declare<void> args<remniw::AsmCodeGeneratorPtr AsmGen, unsigned argNo>;

%%

label: RWIR_LABEL { $cost[0].cost = 0; } = { };

imm: RWIR_CONST { $cost[0].cost = 0; } = { };

reg: RWIR_REG { $cost[0].cost = 0; } = { };

mem: RWIR_ALLOCA(imm) { $cost[0].cost = 0; } = { };

reg: RWIR_LOAD(mem) { $cost[0].cost = $cost[2].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Load(mem)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $0->setRegLoc(true);
    AsmGen->EmitMov($2->getMemLoc(), $0->getRegLocString());
};

reg: RWIR_LOAD(reg) { $cost[0].cost = $cost[2].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Load(reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $0->setRegLoc(true);
    AsmGen->EmitMov('(' + $2->getRegLocString() + ')',
                       $0->getRegLocString());
};

stmt: reg { $cost[0].cost = $cost[1].cost; }
= {
    std::cerr << "[DEBUG] " << "stmt:    reg\n";
    // if ($0->isActionExecuted())
    //     return;
    // $0->setActionExecuted();
    $action[1](AsmGen);
};

stmt: RWIR_RET(reg) { $cost[0].cost = $cost[2].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt:    Ret(reg)\n";
    $action[2](AsmGen);
    AsmGen->EmitMov($2->getRegLocString(), "%rax");
};

stmt: RWIR_RET(imm) { $cost[0].cost = $cost[2].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt:    Ret(imm)\n";
    $action[2](AsmGen);
    AsmGen->EmitMov($2->getImmVal(), "%rax");
};

stmt: RWIR_STORE(reg, mem) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt:   Store(reg, mem)\n";
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitMov($2->getRegLocString(), $3->getMemLoc());
};

stmt: RWIR_STORE(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt:   Store(reg, reg)\n";
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitMov($2->getRegLocString(),
                    '(' + $3->getRegLocString() + ')');
};

stmt: RWIR_STORE(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt:   Store(imm, reg)\n";
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitMov($2->getImmVal(),
                    '(' + $3->getRegLocString() + ')');
};

stmt: RWIR_STORE(imm, mem) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt:   Store(imm, mem)\n";
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitMov($2->getImmVal(), $3->getMemLoc());
};

stmt: RWIR_STORE(mem, mem) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt:   Store(mem, mem)\n";
    $action[2](AsmGen);
    $action[3](AsmGen);
    auto AvailReg = RA->getAvailableRegister();
    const char* AvailRegStr = convertRegisterToString(AvailReg);
    AsmGen->EmitLea($2->getMemLoc(), AvailRegStr);
    AsmGen->EmitMov(AvailRegStr, $3->getMemLoc());
};

stmt: RWIR_STORE(label, mem) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt:   Store(label, mem)\n";
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitMov($2->getLabelStringAsConstant(), $3->getMemLoc());
};

cond: RWIR_ICMP(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "cond: ICmp(reg, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitCmp($3->getRegLocString(), $2->getRegLocString());
};

cond: RWIR_ICMP(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "cond: ICmp(reg, imm)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitCmp($3->getImmVal(), $2->getRegLocString());
};

cond: RWIR_ICMP(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "cond: ICmp(imm, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    auto AvailReg = RA->getAvailableRegister();
    const char* AvailRegStr = convertRegisterToString(AvailReg);
    AsmGen->EmitMov($2->getImmVal(), AvailRegStr);
    AsmGen->EmitCmp($3->getRegLocString(), AvailRegStr);
};

# Conditional Branch
stmt: RWIR_BR(cond, label, label)
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt: Br(cond, label, label)\n";
    $action[2](AsmGen);
    std::string JmpTrue, JmpFalse;
    auto *CI = llvm::cast<llvm::CmpInst>($2->getInstruction());
    switch (CI->getPredicate()) {
    case llvm::CmpInst::Predicate::ICMP_EQ:
        JmpTrue = "je";
        JmpFalse = "jne";
        break;
    case llvm::CmpInst::Predicate::ICMP_NE:
        JmpTrue = "jne";
        JmpFalse = "je";
        break;
    case llvm::CmpInst::Predicate::ICMP_SGT:
        JmpTrue = "jg";
        JmpFalse = "jle";
        break;
    default:
        llvm_unreachable("unexpected CmpInst!\n");
    }
    auto *BI = llvm::cast<llvm::BranchInst>($1->getInstruction());
    llvm::BasicBlock* NextBB = BI->getParent()->getNextNode();
    if (NextBB == BI->getSuccessor(0)) {
        AsmGen->EmitJmp(JmpFalse, $4->getLabelStringAsLabel());
    }
    else if (NextBB == BI->getSuccessor(1)) {
        AsmGen->EmitJmp(JmpTrue, $3->getLabelStringAsLabel());
    }
    else {
        AsmGen->EmitJmp(JmpTrue, $3->getLabelStringAsLabel());
        AsmGen->EmitJmp(JmpFalse, $4->getLabelStringAsLabel());
    }
};

# Unconditional Branch
stmt: RWIR_BR(label, RWIR_UNDEF, RWIR_UNDEF) { $cost[0].cost = $cost[2].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt: Br(label)\n";
    auto *BI = llvm::cast<llvm::BranchInst>($1->getInstruction());
    llvm::BasicBlock* NextBB = BI->getParent()->getNextNode();
    if (NextBB != BI->getSuccessor(0)) {
        AsmGen->EmitJmp("jmp", $2->getLabelStringAsLabel());
    }
};

reg: RWIR_ADD(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Add(reg, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitAdd($2->getRegLocString(), $3->getRegLocString());
    $0->setRegLoc(false, $3->getRegLoc());
};

reg: RWIR_ADD(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Add(reg, imm)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitAdd($3->getImmVal(), $2->getRegLocString());
    $0->setRegLoc(false, $2->getRegLoc());
};

reg: RWIR_ADD(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Add(imm, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitAdd($2->getImmVal(), $3->getRegLocString());
    $0->setRegLoc(false, $3->getRegLoc());
};

reg: RWIR_ADD(imm, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Add(imm, imm)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    llvm_unreachable("unexpected `reg: Add(imm, imm)!`\n");
};

reg: RWIR_SUB(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Sub(reg, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitSub($3->getRegLocString(), $2->getRegLocString());
    $0->setRegLoc(false, $3->getRegLoc());
};

reg: RWIR_SUB(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Sub(reg, imm)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitSub($3->getImmVal(), $2->getRegLocString());
    $0->setRegLoc(false, $2->getRegLoc());
};

reg: RWIR_SUB(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
= {
    std::cerr << "[DEBUG] " << "reg:   Sub(imm, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    $0->setRegLoc(true);
    AsmGen->EmitMov($2->getImmVal(), $0->getRegLocString());
    AsmGen->EmitSub($3->getRegLocString(), $0->getRegLocString());
};

reg: RWIR_SUB(imm, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Sub(imm, imm)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    llvm_unreachable("unexpected `reg: Sub(imm, imm)!`\n");
};

reg: RWIR_MUL(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Mul(reg, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitImul($2->getRegLocString(), $3->getRegLocString());
    $0->setRegLoc(false, $3->getRegLoc());
};

reg: RWIR_MUL(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Mul(reg, imm)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitImul($3->getImmVal(), $2->getRegLocString());
    $0->setRegLoc(false, $2->getRegLoc());
};

reg: RWIR_MUL(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Mul(imm, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitImul($2->getImmVal(), $3->getRegLocString());
    $0->setRegLoc(false, $3->getRegLoc());
};

reg: RWIR_MUL(imm, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Mul(imm, imm)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    llvm_unreachable("unexpected `reg: Mul(imm, imm)!`\n");
};

reg: RWIR_SDIV(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
= {
    std::cerr << "[DEBUG] " << "reg:   SDiv(reg, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitMov($2->getRegLocString(), "%rax");
    AsmGen->EmitCqto();
    AsmGen->EmitIdiv($3->getRegLocString());
    $0->setRegLoc(false, Register::RAX);
};

reg: RWIR_SDIV(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
= {
    std::cerr << "[DEBUG] " << "reg:   SDiv(reg, imm)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    $0->setRegLoc(true);
    AsmGen->EmitMov($2->getRegLocString(), "%rax");
    AsmGen->EmitCqto();
    AsmGen->EmitMov($3->getImmVal(), $0->getRegLocString());
    AsmGen->EmitIdiv($0->getRegLocString());
    AsmGen->EmitMov("%rax", $0->getRegLocString());
};

reg: RWIR_SDIV(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
= {
    std::cerr << "[DEBUG] " << "reg:   SDiv(imm, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitMov($2->getImmVal(), "%rax");
    AsmGen->EmitCqto();
    AsmGen->EmitIdiv($3->getRegLocString());
    $0->setRegLoc(false, Register::RAX);
};

reg: RWIR_SDIV(imm, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
= {
    std::cerr << "[DEBUG] " << "reg:   SDiv(imm, imm)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    llvm_unreachable("unexpected `reg: SDiv(imm, imm)!`\n");
    $0->setRegLoc(true);
    AsmGen->EmitMov($3->getImmVal(), "%rax");
    AsmGen->EmitCqto();
    AsmGen->EmitMov($2->getImmVal(), $0->getRegLocString());
    AsmGen->EmitIdiv($0->getRegLocString());
    AsmGen->EmitMov("%rax", $0->getRegLocString());
};

arg: reg { $cost[0].cost = $cost[1].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "arg:  reg\n";
    $action[1](AsmGen);
    if (argNo < 6) {
        AsmGen->EmitMov($1->getRegLocString(),
                           convertRegisterToString(ArgRegs[argNo]));
    } else {
        AsmGen->EmitMov($1->getRegLocString(),
                           std::to_string(8 * (argNo - 6)) + "(%rsp)");
    }
};

arg: imm { $cost[0].cost = $cost[1].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "arg:  imm\n";
    $action[1](AsmGen);
    if (argNo < 6) {
        AsmGen->EmitMov($1->getImmVal(),
                           convertRegisterToString(ArgRegs[argNo]));
    } else {
        AsmGen->EmitMov($1->getImmVal(),
                           std::to_string(8 * (argNo - 6)) + "(%rsp)");
    }
};

arg: mem { $cost[0].cost = $cost[1].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "arg:  mem\n";
    $action[1](AsmGen);
    if (argNo < 6) {
        AsmGen->EmitLea($1->getMemLoc(),
                           convertRegisterToString(ArgRegs[argNo]));
    } else {
        AsmGen->EmitMov($1->getMemLoc(),
                           std::to_string(8 * (argNo - 6)) + "(%rsp)");
    }
};

arg: label { $cost[0].cost = $cost[1].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "arg:  mem\n";
    $action[1](AsmGen);
    if (argNo < 6) {
        AsmGen->EmitMov($1->getLabelStringAsConstant(),
                           convertRegisterToString(ArgRegs[argNo]));
    } else {
        AsmGen->EmitMov($1->getLabelStringAsConstant(),
                           std::to_string(8 * (argNo - 6)) + "(%rsp)");
    }
};

args: RWIR_ARGS(RWIR_UNDEF, RWIR_UNDEF) { $cost[0].cost = 0; }
= {
    std::cerr << "[DEBUG] " << "args:   ARGS(Undef, Undef)\n";
};

args: RWIR_ARGS(arg, args)  { $cost[0].cost = $cost[2].cost + $cost[3].cost; }
= {
    std::cerr << "[DEBUG] " << "args:   ARGS(value, args)\n";
    $action[2](AsmGen, argNo);
    $action[3](AsmGen, argNo+1);
};

# Direct Call
reg: RWIR_CALL(label, args) { $cost[0].cost = $cost[2].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:    Call(label, args)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen, 0);
    auto* CB = llvm::cast<llvm::CallBase>($1->getInstruction());
    std::string Callee = $2->getLabelStringAsLabel();
    if (Callee == "printf" || Callee == "scanf") {
        AsmGen->EmitXor("%rax", "%rax");
    }
    AsmGen->EmitCall($2->getLabelStringAsLabel());
    $0->setRegLoc(false, Register::RAX);
};

# Indirect Call
reg: RWIR_CALL(reg, args) { $cost[0].cost = $cost[2].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:    Call(reg, args)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen, 0);
    AsmGen->EmitCall("*" + $2->getRegLocString());
    $0->setRegLoc(false, Register::RAX);
};

# Indirect call
reg: RWIR_CALL(mem, args) { $cost[0].cost = $cost[2].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:    Call(mem, args)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen, 0);
    AsmGen->EmitCall("*" + $2->getMemLoc());
    $0->setRegLoc(false, Register::RAX);
};

%%

/* burm_trace - print trace message for matching p */
static void burm_trace(NODEPTR p, int eruleno, COST cost) { }

static void gen(NODEPTR p, remniw::AsmCodeGenerator *AsmGen) {
    if (burm_label(p) == 0)
        std::cerr << "[DEBUG] " << "no cover\n";
    else {
        stmt_action(p->getState(), AsmGen);
    }
}


void printDebugTree(Node *p, int indent=0) {
    if(p != nullptr) {
        if (indent) std::cerr << "|";
        int i = 0;
        for (; i < indent-4; ++i) std::cerr << " ";
        if (indent-4 > 0) std::cerr << "|";
        for (; i < indent; ++i) std::cerr << "-";
        std::cerr << "+ op:" << p->getOp() << ", Kind:" << p->getNodeKind() << "\n";

        for(auto *kid: p->Kids)
        {
            printDebugTree(kid, (indent+4));
        }
    }
}

namespace remniw {

void AsmCodeGenerator::EmitFunction(AsmFunction &F) {
    EmitFunctionDeclaration(F);

    EmitFunctionPrologue(F);

    // body
    for (auto* T: F.ExprTrees) {
        printDebugTree(T);
        if (T->getOp() == /*Label*/69)
            Out << T->getLabelStringAsLabel() << ":\n";
        gen(T, this);
    }

    EmitFunctionEpilogue(F);
}

}  // namespace remniw