%{
#include "helper.h"
%}

# TODO: autogen from llvm/include/llvm/IR/Instruction.def

%term Const         =  0

# Terminator Instructions
%term Ret           =  1
%term Br            =  2
%term Switch        =  3
%term IndirectBr    =  4
%term Invoke        =  5
%term Resume        =  6
%term Unreachable   =  7
%term CleanupRet    =  8
%term CatchRet      =  9
%term CatchSwitch   = 10
%term CallBr        = 11

# Standard unary operators
%term FNeg          = 12

# Standard binary operators
%term Add  = 13
%term FAdd = 14
%term Sub  = 15
%term FSub = 16
%term Mul  = 17
%term FMul = 18
%term UDiv = 19
%term SDiv = 20
%term FDiv = 21
%term URem = 22
%term SRem = 23
%term FRem = 24

# Logical operators (integer operands)
%term Shl  = 25
%term LShr = 26
%term AShr = 27
%term And  = 28
%term Or   = 29
%term Xor  = 30

# Memory operators
%term Alloca        = 31
%term Load          = 32
%term Store         = 33
%term GetElementPtr = 34
%term Fence         = 35
%term AtomicCmpXchg = 36
%term AtomicRMW     = 37

# Cast operators
%term Trunc         = 38
%term ZExt          = 39
%term SExt          = 40
%term FPToUI        = 41
%term FPToSI        = 42
%term UIToFP        = 43
%term SIToFP        = 44
%term FPTrunc       = 45
%term FPExt         = 46
%term PtrToInt      = 47
%term IntToPtr      = 48
%term BitCast       = 49
%term AddrSpaceCast = 50

# FUNCLETPAD
%term CleanupPad    = 51
%term CatchPad      = 52

# Other operators
%term ICmp              = 53
%term FCmp              = 54
%term PHI               = 55
%term Call              = 56
%term Select            = 57
%term UserOp1           = 58
%term UserOp2           = 59
%term VAArg             = 60
%term ExtractElement    = 61
%term InsertElement     = 62
%term ShuffleVector     = 63
%term ExtractValue      = 64
%term InsertValue       = 65
%term LandingPad        = 66
%term Freeze            = 67

%declare<void> stmt<int indent>;
%declare<void> reg<int indent>;
%declare<void> imm<int indent>;
%declare<void> mem<int indent>;

%%

imm:    Const
    { $cost[0].cost = 0; }
    = {
        std::cerr << "imm:    Const\n";
        std::cerr << "\t" << $1->val << "\n";
    };

stmt:   Ret(Load(mem))
    { $cost[0].cost = $cost[3].cost + 1; }
    = {
        $action[3](indent);
        // x64 assembly Ret takes no argument, return value is passed by %rax
        // std::cout << "movq rax, " << $2->getMemVal() << "\n";
        // std::cout << "movq %rbp, %rsp\n";
        // std::cout << "popq %rbp\n";
        // std::cout << "retq\n";
        std::cerr << "stmt:    Ret(reg)\n";
    };

mem:   Alloca(imm)
    { $cost[0].cost = 1; }
    = {
        $action[2](indent);
        std::cerr << "mem:    Alloca(imm)\n";
    };

reg:   Load(mem)
    { $cost[0].cost = $cost[2].cost + 1; }
    = {
        $action[2](indent);
        std::cout << "movq -" << std::to_string($2->offset) << "(%rbp), %reg\n";
        std::cerr << "reg:   Load(mem)\n";
    };

stmt:   Store(Load(mem), mem)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "movq %reg, " << "-" << std::to_string($3->offset) << "(%rbp)\n";
        std::cerr << "stmt:   Store(reg, mem)\n";
    };

stmt:   Store(imm, mem)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "movq $" << std::to_string($2->val) << ", -" << $3->offset << "(%rbp)\n";
        std::cerr << "stmt:   Store(imm, mem)\n";
    };

reg:   Add(Load(mem), Load(mem))
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "addq $" << std::to_string($3->val) << ", %reg\n";
        std::cerr << "stmt:   Add(reg, imm)\n";
    };

reg:   Add(Load(mem), imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "addq $" << std::to_string($3->val) << ", %reg\n";
        std::cerr << "reg:   Add(reg, imm)\n";
    };

reg:   Add(imm, Load(mem))
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "addq $" << std::to_string($2->val) << ", %reg\n";
        std::cerr << "reg:   Add(imm, reg)\n";
    };

reg:   Add(imm, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "FIXME: addq $" << std::to_string($2->val) << "$" << std::to_string($2->val) << "\n";
        std::cerr << "reg:   Add(imm, imm)\n";
    };

reg:   Sub(Load(mem), reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "subq %reg, %reg\n";
        std::cerr << "reg:   Sub(reg, reg)\n";
    };

#reg:   Sub(reg, imm)
#    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
#    = {
#        $action[2](indent);
#        $action[3](indent);
#        std::cout << "movq $" << std::to_string($3->val) << ", %reg\n";
#        std::cout << "subq %reg, reg\n";
#        std::cerr << "reg:   Sub(reg, imm)\n";
#    };

reg:   Sub(imm, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "subq $" << std::to_string($2->val) << ", %reg\n";
        std::cerr << "reg:   Sub(imm, reg)\n";
    };

reg:   Sub(imm, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "FIXME: subq $" << std::to_string($2->val) << "$" << std::to_string($2->val) << "\n";
        std::cerr << "reg:   Sub(imm, imm)\n";
    };

reg:   Mul(reg, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "imulq %reg, %reg\n";
        std::cerr << "reg:   Mul(reg, reg)\n";
    };

reg:   Mul(reg, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "imulq $" << std::to_string($3->val) << ", %reg\n";
        std::cerr << "reg:   Mul(reg, imm)\n";

    };

reg:   Mul(imm, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "imulq $" << std::to_string($2->val) << ", %reg\n";
        std::cerr << "reg:   Mul(imm, reg)\n";
    };

reg:   Mul(imm, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "FIXME: imulq $" << std::to_string($2->val) << "$" << std::to_string($2->val) << "\n";
        std::cerr << "reg:   Mul(imm, imm)\n";
    };

reg:   SDiv(reg, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "movq $0, %rdx\n";
        std::cout << "movq %reg3, %rax\n";
        std::cout << "cqto\n";
        std::cout << "idivq %reg2\n";
        std::cerr << "reg:   SDiv(reg, reg)\n";
    };

reg:   SDiv(reg, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "movq $0, %rdx\n";
        std::cout << "movq $" << std::to_string($3->val) << ", %rax\n";
        std::cout << "cqto\n";
        std::cout << "idivq %reg2\n";
        std::cerr << "reg:   SDiv(reg, imm)\n";

    };

reg:   SDiv(imm, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "movq $0, %rdx\n";
        std::cout << "movq %reg3, %rax\n";
        std::cout << "cqto\n";
        std::cout << "movq $" << std::to_string($2->val) << ", %reg\n";
        std::cout << "idivq %reg\n";
        std::cerr << "reg:   SDiv(imm, reg)\n";
    };

reg:   SDiv(imm, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "movq $0, %rdx\n";
        std::cout << "movq $" << std::to_string($3->val) << ", %rax\n";
        std::cout << "cqto\n";
        std::cout << "movq $" << std::to_string($2->val) << ", %reg\n";
        std::cout << "idivq %reg\n";
        std::cerr << "reg:   SDiv(imm, imm)\n";
    };

%%

/* burm_trace - print trace message for matching p */
static void burm_trace(NODEPTR p, int eruleno, COST cost) {
	if (shouldTrace)
		std::cerr << "0x" << p << " matched " << burm_string[eruleno] << " = " << eruleno << " with cost " << cost.cost << "\n";
}

static void gen(NODEPTR p) {
    if (burm_label(p) == 0)
        std::cerr << "no cover\n";
    else {
        stmt_action(p->x.state,0);
        if (shouldCover != 0)
            dumpCover(p, 1, 0);
    }
}

static Tree* tree(int op, Tree* l, Tree* r) {
    Tree* t = (Tree*) malloc(sizeof *t);

    t->op = op;
    t->kids[0] = l; t->kids[1] = r;
    t->val = 0;
    t->x.state = 0;
    return t;
}

#include "llvm/IR/Module.h"
#include "llvm/IR/LLVMContext.h"
// #include "llvm/Support/CommandLine.h"
#include "llvm/Support/SourceMgr.h"
#include "llvm/IRReader/IRReader.h"

using namespace llvm;

void FunctionASM::EmitAssembly()
{
    // FIXME
    std::cout << ".text\n.globl main\n.type main, @function\nmain:\n";

    // prologue
    std::cout << "pushq %rbp\n";
    std::cout << "movq %rsp, %rbp\n";
    std::cout << "subq $" << std::to_string(LovalVariableSpaceInBytes) << ", %rsp\n";

    // body
    for(auto* T: ExprTrees)
    {
        gen(T);
    }

    // epilogue
    std::cout << "movq %rbp, %rsp\n";
    std::cout << "popq %rbp\n";
    std::cout << "retq\n\n";
}

//static cl::opt<std::string>
//InputFilename(cl::Positional, cl::desc("<input bitcode>"), cl::init("-"));

int main(int argc, char *argv[]) {

    Tree* t;
    int i;

    for (i = 1; i < argc ; ++i) {
        if (strcmp(argv[i], "--cover") == 0){
            shouldCover = 1;
        }
        if (strcmp(argv[i], "--trace") == 0){
            shouldTrace = 1;
        }
    }
    printf("a = 1 - 2 + 0;\n");
    t = tree(Ret,
            tree(Load,
                (t = tree(Alloca,
                          (t = tree(0, nullptr, nullptr), t->val=8, t),
                          nullptr), t),
                nullptr),
            nullptr
    );
    gen(t);
    return 0;

    // parse arguments from command line
    // cl::ParseCommandLineOptions(argc, argv, "llc-olive\n");

    // prepare llvm context to read bitcode file
    LLVMContext Context;
    SMDiagnostic Error;
    std::unique_ptr<Module> M = parseIRFile(/*InputFilename*/argv[1], Error, Context);

    ExprTreeBuilder Builder(M->getDataLayout());
    Builder.visit(*M);
    for(auto& F: Builder.Functions)
    {
        F.EmitAssembly();
    }
    return 0;
}
