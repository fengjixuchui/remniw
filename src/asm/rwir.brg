%{
#include "helper.h"
%}

# TODO: autogen from llvm/include/llvm/IR/Instruction.def

%term Undef         =  0

# Terminator Instructions
%term Ret           =  1
%term Br            =  2
%term Switch        =  3
%term IndirectBr    =  4
%term Invoke        =  5
%term Resume        =  6
%term Unreachable   =  7
%term CleanupRet    =  8
%term CatchRet      =  9
%term CatchSwitch   = 10
%term CallBr        = 11

# Standard unary operators
%term FNeg          = 12

# Standard binary operators
%term Add  = 13
%term FAdd = 14
%term Sub  = 15
%term FSub = 16
%term Mul  = 17
%term FMul = 18
%term UDiv = 19
%term SDiv = 20
%term FDiv = 21
%term URem = 22
%term SRem = 23
%term FRem = 24

# Logical operators (integer operands)
%term Shl  = 25
%term LShr = 26
%term AShr = 27
%term And  = 28
%term Or   = 29
%term Xor  = 30

# Memory operators
%term Alloca        = 31
%term Load          = 32
%term Store         = 33
%term GetElementPtr = 34
%term Fence         = 35
%term AtomicCmpXchg = 36
%term AtomicRMW     = 37

# Cast operators
%term Trunc         = 38
%term ZExt          = 39
%term SExt          = 40
%term FPToUI        = 41
%term FPToSI        = 42
%term UIToFP        = 43
%term SIToFP        = 44
%term FPTrunc       = 45
%term FPExt         = 46
%term PtrToInt      = 47
%term IntToPtr      = 48
%term BitCast       = 49
%term AddrSpaceCast = 50

# FUNCLETPAD
%term CleanupPad    = 51
%term CatchPad      = 52

# Other operators
%term ICmp              = 53
%term FCmp              = 54
%term PHI               = 55
%term Call              = 56
%term Select            = 57
%term UserOp1           = 58
%term UserOp2           = 59
%term VAArg             = 60
%term ExtractElement    = 61
%term InsertElement     = 62
%term ShuffleVector     = 63
%term ExtractValue      = 64
%term InsertValue       = 65
%term LandingPad        = 66
%term Freeze            = 67

%term Const            = 68
%term Label            = 69
%term Args             = 70
%term Reg              = 71

%declare<void> stmt<llvm::raw_ostream &Out>;
%declare<void> reg<llvm::raw_ostream &Out>;
%declare<void> imm<llvm::raw_ostream &Out>;
%declare<void> mem<llvm::raw_ostream &Out>;
%declare<void> label<llvm::raw_ostream &Out>;
%declare<void> cond<llvm::raw_ostream &Out>;
%declare<void> arg<llvm::raw_ostream &Out, unsigned argNo>;
%declare<void> args<llvm::raw_ostream &Out, unsigned argNo>;

%%

imm:    Const
    { $cost[0].cost = 0; }
    = {
        std::cerr << "[DEBUG] " << "imm:    Const\n";
        std::cerr << "[DEBUG] " << "\t" << $1->getImmVal() << "\n";
    };

reg:    Reg
    { $cost[0].cost = 0; }
    = {
        std::cerr << "[DEBUG] " << "reg:    Reg\n";
    };

stmt:   Ret(reg)
    { $cost[0].cost = $cost[2].cost + 1; }
    = {
        $action[2](Out);
        // x64 assembly Ret takes no argument, return value is passed by %rax
        std::cerr << "[DEBUG] " << "stmt:    Ret(reg)\n";
        Out << "movq " << $2->getRegLocString() << ", %rax\n";
    };

stmt:   Ret(imm)
    { $cost[0].cost = $cost[2].cost + 1; }
    = {
        $action[2](Out);
        // x64 assembly Ret takes no argument, return value is passed by %rax
        std::cerr << "[DEBUG] " << "stmt:    Ret(imm)\n";
        Out << "movq " << $2->getImmVal() << ", %rax\n";
    };

mem:   Alloca(imm)
    { $cost[0].cost = 1; }
    = {
        $action[2](Out);
        std::cerr << "[DEBUG] " << "mem:    Alloca(imm)\n";
    };

reg:   Load(mem)
    { $cost[0].cost = $cost[2].cost + 1; }
    = {
        $action[2](Out);
        $0->setRegLoc(true);
        std::cerr << "[DEBUG] " << "reg:   Load(mem)\n";
        Out << "movq " << $2->getMemLoc() << ", "
                  << $0->getRegLocString() << "\n";
    };

reg:   Load(reg)
    { $cost[0].cost = $cost[2].cost + 1; }
    = {
        $action[2](Out);
        $0->setRegLoc(true);
        std::cerr << "[DEBUG] " << "reg:   Load(reg)\n";
        Out << "movq (" << $2->getRegLocString() << "), "
                  << $0->getRegLocString() << "\n";
    };

stmt:   Store(reg, mem)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "stmt:   Store(reg, mem)\n";
        Out << "movq " << $2->getRegLocString() << ", "
                  << $3->getMemLoc() << "\n";
    };

stmt:   Store(reg, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "stmt:   Store(reg, reg)\n";
        Out << "movq " << $2->getRegLocString() << ", "
                  << "(" << $3->getRegLocString() << ")\n";
    };

stmt:   Store(imm, mem)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "stmt:   Store(imm, mem)\n";
        Out << "movq " << $2->getImmVal() << ","
                  << $3->getMemLoc() << "\n";
    };

stmt:   Store(mem, mem)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "stmt:   Store(imm, mem)\n";
        auto AvailableRegister = RA->getAvailableRegister();
        Out << "leaq " << $2->getMemLoc() << ", "
                  << convertRegisterToString(AvailableRegister) << "\n";
        Out << "movq " << convertRegisterToString(AvailableRegister) << ", " << $3->getMemLoc() << "\n";
    };

stmt:   Store(label, mem)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "stmt:   Store(label, mem)\n";
        Out << "movq " << $2->getLabelString3() << ","
                  << $3->getMemLoc() << "\n";
    };

label: Label
    { $cost[0].cost = 0; }
    = {
        std::cerr << "[DEBUG] " << "label: Label\n";
    };

cond: ICmp(reg, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 0; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "cond: ICmp(reg, reg)\n";
        Out << "cmpq " << $3->getRegLocString() << ", " << $2->getRegLocString() << "\n";
    };

cond: ICmp(reg, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 0; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "cond: ICmp(reg, imm)\n";
        Out << "cmpq " << $3->getImmVal() << ", " << $2->getRegLocString() << "\n";
    };

cond: ICmp(imm, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 0; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "cond: ICmp(imm, reg)\n";
        auto AvailableRegister = RA->getAvailableRegister();
        Out << "movq " << $2->getImmVal() << ", "
                  << convertRegisterToString(AvailableRegister) << "\n";
        Out << "cmpq " << $3->getRegLocString() << ", " << convertRegisterToString(AvailableRegister) << "\n";
    };

# conditional jump
stmt: Br(cond, label, label)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 1; }
    = {
        $action[2](Out);
        std::string JmpTrue, JmpFalse;
        auto *CI = llvm::cast<llvm::CmpInst>($2->getInstruction());
        switch (CI->getPredicate()) {
            case llvm::CmpInst::Predicate::ICMP_EQ:
                JmpTrue = "je ";
                JmpFalse = "jne ";
                break;
            case llvm::CmpInst::Predicate::ICMP_NE:
                JmpTrue = "jne ";
                JmpFalse = "je ";
                break;
            case llvm::CmpInst::Predicate::ICMP_SGT:
                JmpTrue = "jg ";
                JmpFalse = "jle ";
                break;
            default:
                llvm_unreachable("unexpected CmpInst!\n");
        }
        std::cerr << "[DEBUG] " << "stmt: Br(cond, label, label)\n";
        llvm::BasicBlock* NextBB = CI->getParent()->getNextNode();
        auto *BI = llvm::cast<llvm::BranchInst>($1->getInstruction());
        if (NextBB == BI->getSuccessor(0))
        {
            Out << JmpFalse << $4->getLabelString() << "\n";
        }
        else if (NextBB == BI->getSuccessor(1))
        {
            Out << JmpTrue << $3->getLabelString() << "\n";
        }
        else
        {
            Out << JmpTrue << $3->getLabelString() << "\n";
            Out << JmpFalse << $4->getLabelString() << "\n";
        }
    };

# unconditional jump
stmt: Br(label, Undef, Undef)
    { $cost[0].cost = $cost[2].cost + 1; }
    = {
        std::cerr << "[DEBUG] " << "stmt: Br(label)\n";
        Out << "jmp " << $2->getLabelString() << "\n";
    };

reg:   Add(reg, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "reg:   Add(reg, reg)\n";
        Out << "addq " << $2->getRegLocString() << ", " << $3->getRegLocString() << "\n";
        $0->setRegLoc(false, $3->getRegLoc());
    };

reg:   Add(reg, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "reg:   Add(reg, imm)\n";
        Out << "addq " << $3->getImmVal() << ", "
                  << $2->getRegLocString() << "\n";
        $0->setRegLoc(false, $2->getRegLoc());
    };

reg:   Add(imm, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "reg:   Add(imm, reg)\n";
        Out << "addq " << $2->getImmVal() << ", "
                  << $3->getRegLocString() << "\n";
        $0->setRegLoc(false, $3->getRegLoc());
    };

reg:   Add(imm, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "reg:   Add(imm, imm)\n";
        Out << "FIXME: addq " << $2->getImmVal() << ", " << $2->getImmVal() << "\n";
    };

reg:   Sub(reg, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "reg:   Sub(reg, reg)\n";
        Out << "subq " << $2->getRegLocString() << ", "
                  << $3->getRegLocString() << "\n";
        $0->setRegLoc(false, $3->getRegLoc());
    };

reg:   Sub(reg, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "reg:   Sub(reg, imm)\n";
        $0->setRegLoc(true);
        Out << "movq " << $3->getImmVal() << ", "
                  << $0->getRegLocString() << "\n";
        Out << "subq " << $2->getRegLocString() << ", "
                  << $0->getRegLocString() << "\n";
    };

reg:   Sub(imm, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "reg:   Sub(imm, reg)\n";
        Out << "subq " << $2->getImmVal() << ", "
                  << $3->getRegLocString() << "\n";
        $0->setRegLoc(false, $3->getRegLoc());
    };

reg:   Sub(imm, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "reg:   Sub(imm, imm)\n";
        Out << "FIXME: subq " << $2->getImmVal() << ", " << $2->getImmVal() << "\n";
    };

reg:   Mul(reg, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "reg:   Mul(reg, reg)\n";
        Out << "imulq " << $2->getRegLocString() << ", "
                  << $3->getRegLocString() << "\n";
        $0->setRegLoc(false, $3->getRegLoc());
    };

reg:   Mul(reg, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "reg:   Mul(reg, imm)\n";
        Out << "imulq " << $3->getImmVal() << ", "
                  << $2->getRegLocString() << "\n";
        $0->setRegLoc(false, $2->getRegLoc());
    };

reg:   Mul(imm, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "reg:   Mul(imm, reg)\n";
        Out << "imulq " << $2->getImmVal() << ", "
                  << $3->getRegLocString() << "\n";
        $0->setRegLoc(false, $3->getRegLoc());
    };

reg:   Mul(imm, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "reg:   Mul(imm, imm)\n";
        Out << "FIXME: imulq " << $2->getImmVal() << ", " << $2->getImmVal() << "\n";
    };

reg:   SDiv(reg, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "reg:   SDiv(reg, reg)\n";
        Out << "movq " << $2->getRegLocString() << ", %rax\n";
        Out << "cqto\n";
        Out << "idivq " << $3->getRegLocString() << "\n";
        $0->setRegLoc(false, Register::RAX);
    };

reg:   SDiv(reg, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "reg:   SDiv(reg, imm)\n";
        Out << "movq " << $2->getRegLocString() << ", %rax\n";
        Out << "cqto\n";
        $0->setRegLoc(true);
        Out << "movq " << $3->getImmVal() << ", "
                  << $0->getRegLocString() << "\n";
        Out << "idivq " << $0->getRegLocString() << "\n";
        Out << "movq %rax, " << $0->getRegLocString() << "\n";
    };

reg:   SDiv(imm, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "reg:   SDiv(imm, reg)\n";
        Out << "movq " << $2->getImmVal() << ", %rax\n";
        Out << "cqto\n";
        Out << "idivq " << $3->getRegLocString() << "\n";
        $0->setRegLoc(false, Register::RAX);
    };

reg:   SDiv(imm, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](Out);
        $action[3](Out);
        std::cerr << "[DEBUG] " << "reg:   SDiv(imm, imm)\n";
        Out << "movq " << $3->getImmVal() << ", %rax\n";
        Out << "cqto\n";
        $0->setRegLoc(true);
        Out << "movq " << $2->getImmVal() << ", "
                  << $0->getRegLocString() << "\n";
        Out << "idivq " << $0->getRegLocString() << "\n";
        Out << "movq %rax, " << $0->getRegLocString() << "\n";
    };

arg:  reg
    { $cost[0].cost = $cost[1].cost; }
    = {
        $action[1](Out);
        std::cerr << "[DEBUG] " << "arg:  reg\n";
        if (argNo < 6)
            Out << "movq " << $0->getRegLocString() << ", "
                      << convertRegisterToString(ArgRegs[argNo]) << "\n";
        else
            Out << "TODO: stack pass argument\n";
    };

arg:  imm
    { $cost[0].cost = $cost[1].cost; }
    = {
        std::cerr << "[DEBUG] " << "arg:  imm\n";
        if (argNo < 6)
            Out << "movq " << $1->getImmVal() << ", "
                      << convertRegisterToString(ArgRegs[argNo]) << "\n";
        else
            Out << "TODO: stack pass argument\n";
    };

arg:  mem
    { $cost[0].cost = $cost[1].cost; }
    = {
        std::cerr << "[DEBUG] " << "arg:  mem\n";
        if (argNo < 6)
            Out << "movq " << $1->getMemLoc() << ", "
                      << convertRegisterToString(ArgRegs[argNo]) << "\n";
        else
            Out << "TODO: stack pass argument\n";
    };

arg: label
    { $cost[0].cost = $cost[1].cost; }
    = {
        std::cerr << "[DEBUG] " << "arg:  mem\n";
        if (argNo < 6)
            Out << "movq " << $1->getLabelString4() << ", "
                      << convertRegisterToString(ArgRegs[argNo]) << "\n";
        else
            Out << "TODO: stack pass argument\n";
    };

args:   Args(Undef, Undef)
    { $cost[0].cost = 0; }
    = {
        std::cerr << "[DEBUG] " << "args:   ARGS(Undef, Undef)\n";
    };

args:   Args(arg, args)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](Out, argNo);
        $action[3](Out, argNo+1);
        std::cerr << "[DEBUG] " << "args:   ARGS(value, args)\n";
    };

# direct call
reg:    Call(label, args)
    { $cost[0].cost = $cost[2].cost + 1; }
    = {
        std::cerr << "[DEBUG] " << "reg:    Call(label, args)\n";
        $action[2](Out);
        $action[3](Out, 0);
        auto* CB = llvm::cast<llvm::CallBase>($1->getInstruction());
        Out << "callq " << $2->getLabelString2() << "\n";
        $0->setRegLoc(false, Register::RAX);
    };

# indirect call
reg:    Call(reg, args)
    { $cost[0].cost = $cost[2].cost + 1; }
    = {
        std::cerr << "[DEBUG] " << "reg:    Call(reg, args)\n";
        $action[2](Out);
        $action[3](Out, 0);
        Out << "callq " << "*" << $2->getRegLocString() << "\n";
        $0->setRegLoc(false, Register::RAX);
    };

# indirect call
reg:    Call(mem, args)
    { $cost[0].cost = $cost[2].cost + 1; }
    = {
        std::cerr << "[DEBUG] " << "reg:    Call(mem, args)\n";
        $action[2](Out);
        $action[3](Out, 0);
        Out << "callq " << "*" << $2->getMemLoc() << "\n";
        $0->setRegLoc(false, Register::RAX);
    };

# FIXME, stmt: Call?
stmt:    reg
    { $cost[0].cost = 0; }
    = {
        std::cerr << "[DEBUG] " << "stmt:    reg\n";
        $action[1](Out);
    };

%%

/* burm_trace - print trace message for matching p */
static void burm_trace(NODEPTR p, int eruleno, COST cost) {
	if (shouldTrace)
		std::cerr << "[DEBUG] " << "0x" << p << " matched " << burm_string[eruleno] << " = " << eruleno << " with cost " << cost.getCost() << "\n";
}

static void gen(NODEPTR p, llvm::raw_ostream &Out) {
    if (burm_label(p) == 0)
        std::cerr << "[DEBUG] " << "no cover\n";
    else {
        stmt_action(p->getState(), Out);
        if (shouldCover != 0)
            dumpCover(p, 1, 0);
    }
}

#include "llvm/IR/Module.h"
#include "llvm/IR/LLVMContext.h"
// #include "llvm/Support/CommandLine.h"
#include "llvm/Support/SourceMgr.h"
#include "llvm/IRReader/IRReader.h"

using namespace llvm;

void printDebugTree(Node *p, int indent=0) {
    if(p != nullptr) {
        if (indent) std::cerr << "|";
        int i = 0;
        for (; i < indent-4; ++i) std::cerr << " ";
        if (indent-4 > 0) std::cerr << "|";
        for (; i < indent; ++i) std::cerr << "-";
        std::cerr << "+ op:" << p->getOp() << ", Kind:" << p->getNodeKind() << "\n";

        for(auto *kid: p->Kids)
        {
            printDebugTree(kid, (indent+4));
        }
    }
}

void AsmFunction::EmitAssembly(llvm::raw_ostream &Out)
{
    // FIXME
    Out << ".text\n"
              << ".globl " << FuncName << "\n"
              << ".type " << FuncName << ", @function\n"
              << FuncName << ":\n";

    // prologue
    Out << "pushq %rbp\n";
    Out << "movq %rsp, %rbp\n";
    Out << "subq $" << TotalAllocaSizeInBytes << ", %rsp\n";

    // body
    for(auto* T: ExprTrees)
    {
        {
        printDebugTree(T);
        // continue;
        }
        if (T->getOp() == /*Label*/69)
            Out << T->getLabelString() << ":\n";
        gen(T, Out);
    }

    // epilogue
    Out << "movq %rbp, %rsp\n";
    Out << "popq %rbp\n";
    Out << "retq\n\n";
}

//static cl::opt<std::string>
//InputFilename(cl::Positional, cl::desc("<input bitcode>"), cl::init("-"));

int main(int argc, char *argv[]) {
/*
    Tree t;
    int i;

    for (i = 1; i < argc ; ++i) {
        if (strcmp(argv[i], "--cover") == 0){
            shouldCover = 1;
        }
        if (strcmp(argv[i], "--trace") == 0){
            shouldTrace = 1;
        }
    }
*/

    // parse arguments from command line
    // cl::ParseCommandLineOptions(argc, argv, "llc-olive\n");

    // prepare llvm context to read bitcode file
    LLVMContext Context;
    SMDiagnostic Error;
    std::unique_ptr<Module> M = parseIRFile(/*InputFilename*/argv[1], Error, Context);

    ExprTreeBuilder Builder(M->getDataLayout());
    Builder.visit(*M);

    CodeGenerator CG(Builder.Functions, Builder.ConstantStrings);
    CG.EmitAssembly();

    return 0;
}
