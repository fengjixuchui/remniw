%{
#include "helper.h"
%}

# TODO: autogen from llvm/include/llvm/IR/Instruction.def

%term Undef         =  0

# Terminator Instructions
%term Ret           =  1
%term Br            =  2
%term Switch        =  3
%term IndirectBr    =  4
%term Invoke        =  5
%term Resume        =  6
%term Unreachable   =  7
%term CleanupRet    =  8
%term CatchRet      =  9
%term CatchSwitch   = 10
%term CallBr        = 11

# Standard unary operators
%term FNeg          = 12

# Standard binary operators
%term Add  = 13
%term FAdd = 14
%term Sub  = 15
%term FSub = 16
%term Mul  = 17
%term FMul = 18
%term UDiv = 19
%term SDiv = 20
%term FDiv = 21
%term URem = 22
%term SRem = 23
%term FRem = 24

# Logical operators (integer operands)
%term Shl  = 25
%term LShr = 26
%term AShr = 27
%term And  = 28
%term Or   = 29
%term Xor  = 30

# Memory operators
%term Alloca        = 31
%term Load          = 32
%term Store         = 33
%term GetElementPtr = 34
%term Fence         = 35
%term AtomicCmpXchg = 36
%term AtomicRMW     = 37

# Cast operators
%term Trunc         = 38
%term ZExt          = 39
%term SExt          = 40
%term FPToUI        = 41
%term FPToSI        = 42
%term UIToFP        = 43
%term SIToFP        = 44
%term FPTrunc       = 45
%term FPExt         = 46
%term PtrToInt      = 47
%term IntToPtr      = 48
%term BitCast       = 49
%term AddrSpaceCast = 50

# FUNCLETPAD
%term CleanupPad    = 51
%term CatchPad      = 52

# Other operators
%term ICmp              = 53
%term FCmp              = 54
%term PHI               = 55
%term Call              = 56
%term Select            = 57
%term UserOp1           = 58
%term UserOp2           = 59
%term VAArg             = 60
%term ExtractElement    = 61
%term InsertElement     = 62
%term ShuffleVector     = 63
%term ExtractValue      = 64
%term InsertValue       = 65
%term LandingPad        = 66
%term Freeze            = 67

%term Const            = 68
%term Label            = 69

%declare<void> stmt<int indent>;
%declare<void> reg<int indent>;
%declare<void> imm<int indent>;
%declare<void> mem<int indent>;
%declare<void> label<int indent>;
%declare<void> cond<int indent>;

%%

imm:    Const
    { $cost[0].cost = 0; }
    = {
        std::cerr << "[DEBUG] " << "imm:    Const\n";
        std::cerr << "[DEBUG] " << "\t" << $1->getImmVal() << "\n";
    };

stmt:   Ret(reg)
    { $cost[0].cost = $cost[2].cost + 1; }
    = {
        $action[2](indent);
        // x64 assembly Ret takes no argument, return value is passed by %rax
        std::cout << "movq " << $2->getRegLocString() << ", %rax\n";
        std::cerr << "[DEBUG] " << "stmt:    Ret(reg)\n";
    };

mem:   Alloca(imm)
    { $cost[0].cost = 1; }
    = {
        $action[2](indent);
        std::cerr << "[DEBUG] " << "mem:    Alloca(imm)\n";
    };

reg:   Load(mem)
    { $cost[0].cost = $cost[2].cost + 1; }
    = {
        $action[2](indent);
        $0->setRegLoc(true);
        std::cout << "movq " << $2->getMemLoc() << ", "
                  << $0->getRegLocString() << "\n";
        std::cerr << "[DEBUG] " << "reg:   Load(mem)\n";
    };

reg:   Load(reg)
    { $cost[0].cost = $cost[2].cost + 1; }
    = {
        $action[2](indent);
        $0->setRegLoc(true);
        std::cout << "movq (" << $2->getRegLocString() << "), "
                  << $0->getRegLocString() << "\n";
        std::cerr << "[DEBUG] " << "reg:   Load(reg)\n";
    };

stmt:   Store(reg, mem)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "movq " << $2->getRegLocString() << ", "
                  << $3->getMemLoc() << "\n";
        std::cerr << "[DEBUG] " << "stmt:   Store(reg, mem)\n";
    };

#FIXME
#  %x = alloca i64, align 8
#  %y = alloca i64*, align 8
#  %y2 = load i64*, i64** %y, align 8
#  %1 = load i64, i64* %y2, align 8
#  %2 = load i64*, i64** %y, align 8
#  store i64 %1, i64* %2, align 8
stmt:   Store(reg, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "movq " << $2->getRegLocString() << ", "
                  << "(" << $3->getRegLocString() << ")\n";
        std::cerr << "[DEBUG] " << "stmt:   Store(reg, reg)\n";
    };

stmt:   Store(imm, mem)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "movq " << $2->getImmVal() << ","
                  << $3->getMemLoc() << "\n";
        std::cerr << "[DEBUG] " << "stmt:   Store(imm, mem)\n";
    };

stmt:   Store(mem, mem)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost; }
    = {
        $action[2](indent);
        $action[3](indent);
        $0->setRegLoc(true);
        std::cout << "leaq " << $2->getMemLoc() << ", "
                  << $0->getRegLocString() << "\n";
        std::cout << "movq " << $0->getRegLocString() << ", " << $3->getMemLoc() << "\n";
        std::cerr << "[DEBUG] " << "stmt:   Store(imm, mem)\n";
    };

label: Label
    { $cost[0].cost = 0; }
    = {
        std::cerr << "[DEBUG] " << "label: Label\n";
        // std::cout << $1->getLabelString() << "\n";
    };

cond: ICmp(reg, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 0; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cerr << "[DEBUG] " << "cond: ICmp(reg, reg)\n";
        std::cout << "cmpq " << $3->getRegLocString() << ", " << $2->getRegLocString() << "\n";
    };

cond: ICmp(reg, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 0; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cerr << "[DEBUG] " << "cond: ICmp(reg, imm)\n";
        std::cout << "cmpq " << $3->getImmVal() << ", " << $2->getRegLocString() << "\n";
    };

cond: ICmp(imm, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 0; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cerr << "[DEBUG] " << "cond: ICmp(imm, reg)\n";
        // FIXME: here we manually use Register R9
        std::cout << "movq " << $2->getImmVal() << ", "
                  << "%r9" << "\n";
        std::cout << "cmpq " << $3->getRegLocString() << ", " << "%r9" << "\n";
    };

# conditional jump
stmt: Br(cond, label, label)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 1; }
    = {
        $action[2](indent);
        std::string JmpTrue, JmpFalse;
        auto *CI = llvm::cast<llvm::CmpInst>($2->getInstruction());
            switch (CI->getPredicate()) {
            case llvm::CmpInst::Predicate::ICMP_EQ:
                JmpTrue = "je ";
                JmpFalse = "jne ";
                break;
            case llvm::CmpInst::Predicate::ICMP_NE:
                JmpTrue = "jne ";
                JmpFalse = "je ";
                break;
            case llvm::CmpInst::Predicate::ICMP_SGT:
                JmpTrue = "jg ";
                JmpFalse = "jle ";
                break;
            default:
                llvm_unreachable("unexpected CmpInst!\n");
            }
        // std::cout << op << $4->getRegLocString() << "\n";
        std::cerr << "[DEBUG] " << "stmt: Br(cond, label, label)\n";
        llvm::BasicBlock* NextBB = CI->getParent()->getNextNode();
        if (NextBB == $3->getBasicBlock())
        {
            std::cout << JmpFalse << $4->getLabelString() << "\n";
        }
        else if (NextBB == $4->getBasicBlock())
        {
            std::cout << JmpTrue << $3->getLabelString() << "\n";
        }
        else
        {
            std::cout << JmpTrue << $3->getLabelString() << "\n";
            std::cout << JmpFalse << $4->getLabelString() << "\n";
        }
    };

# unconditional jump
stmt: Br(label, Undef, Undef)
    { $cost[0].cost = $cost[2].cost + 1; }
    = {
        std::cout << "jmp " << $2->getLabelString() << "\n";
        std::cerr << "[DEBUG] " << "stmt: Br(label)\n";
    };

reg:   Add(reg, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "addq " << $2->getRegLocString() << ", " << $3->getRegLocString() << "\n";
        $0->setRegLoc(false, $3->getRegLoc());
        std::cerr << "[DEBUG] " << "reg:   Add(reg, reg)\n";
    };

reg:   Add(reg, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "addq " << $3->getImmVal() << ", "
                  << $2->getRegLocString() << "\n";
        $0->setRegLoc(false, $2->getRegLoc());
        std::cerr << "[DEBUG] " << "reg:   Add(reg, imm)\n";
    };

reg:   Add(imm, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "addq " << $2->getImmVal() << ", "
                  << $3->getRegLocString() << "\n";
        $0->setRegLoc(false, $3->getRegLoc());
        std::cerr << "[DEBUG] " << "reg:   Add(imm, reg)\n";
    };

reg:   Add(imm, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "FIXME: addq " << $2->getImmVal() << ", " << $2->getImmVal() << "\n";
        std::cerr << "[DEBUG] " << "reg:   Add(imm, imm)\n";
    };

reg:   Sub(reg, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "subq " << $2->getRegLocString() << ", "
                  << $3->getRegLocString() << "\n";
        $0->setRegLoc(false, $3->getRegLoc());
        std::cerr << "[DEBUG] " << "reg:   Sub(reg, reg)\n";
    };

reg:   Sub(reg, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        $0->setRegLoc(true);
        std::cout << "movq " << $3->getImmVal() << ", "
                  << $0->getRegLocString() << "\n";
        std::cout << "subq " << $2->getRegLocString() << ", "
                  << $0->getRegLocString() << "\n";
        std::cerr << "[DEBUG] " << "reg:   Sub(reg, imm)\n";
    };

reg:   Sub(imm, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "subq " << $2->getImmVal() << ", "
                  << $3->getRegLocString() << "\n";
        $0->setRegLoc(false, $3->getRegLoc());
        std::cerr << "[DEBUG] " << "reg:   Sub(imm, reg)\n";
    };

reg:   Sub(imm, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "FIXME: subq " << $2->getImmVal() << ", " << $2->getImmVal() << "\n";
        std::cerr << "[DEBUG] " << "reg:   Sub(imm, imm)\n";
    };

reg:   Mul(reg, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "imulq " << $2->getRegLocString() << ", "
                  << $3->getRegLocString() << "\n";
        $0->setRegLoc(false, $3->getRegLoc());
        std::cerr << "[DEBUG] " << "reg:   Mul(reg, reg)\n";
    };

reg:   Mul(reg, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "imulq " << $3->getImmVal() << ", "
                  << $2->getRegLocString() << "\n";
        $0->setRegLoc(false, $2->getRegLoc());
        std::cerr << "[DEBUG] " << "reg:   Mul(reg, imm)\n";

    };

reg:   Mul(imm, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "imulq " << $2->getImmVal() << ", "
                  << $3->getRegLocString() << "\n";
        $0->setRegLoc(false, $3->getRegLoc());
        std::cerr << "[DEBUG] " << "reg:   Mul(imm, reg)\n";
    };

reg:   Mul(imm, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "FIXME: imulq " << $2->getImmVal() << ", " << $2->getImmVal() << "\n";
        std::cerr << "[DEBUG] " << "reg:   Mul(imm, imm)\n";
    };

reg:   SDiv(reg, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "movq " << $2->getRegLocString() << ", %rax\n";
        std::cout << "cqto\n";
        std::cout << "idivq " << $3->getRegLocString() << "\n";
        $0->setRegLoc(false, Register::RAX);
        std::cerr << "[DEBUG] " << "reg:   SDiv(reg, reg)\n";
    };

reg:   SDiv(reg, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "movq " << $2->getRegLocString() << ", %rax\n";
        std::cout << "cqto\n";
        $0->setRegLoc(true);
        std::cout << "movq " << $3->getImmVal() << ", "
                  << $0->getRegLocString() << "\n";
        std::cout << "idivq " << $0->getRegLocString() << "\n";
        std::cout << "movq %rax, " << $0->getRegLocString() << "\n";
        std::cerr << "[DEBUG] " << "reg:   SDiv(reg, imm)\n";

    };

reg:   SDiv(imm, reg)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "movq " << $2->getImmVal() << ", %rax\n";
        std::cout << "cqto\n";
        std::cout << "idivq " << $3->getRegLocString() << "\n";
        $0->setRegLoc(false, Register::RAX);
        std::cerr << "[DEBUG] " << "reg:   SDiv(imm, reg)\n";
    };

reg:   SDiv(imm, imm)
    { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
    = {
        $action[2](indent);
        $action[3](indent);
        std::cout << "movq " << $3->getImmVal() << ", %rax\n";
        std::cout << "cqto\n";
        $0->setRegLoc(true);
        std::cout << "movq " << $2->getImmVal() << ", "
                  << $0->getRegLocString() << "\n";
        std::cout << "idivq " << $0->getRegLocString() << "\n";
        std::cout << "movq %rax, " << $0->getRegLocString() << "\n";
        std::cerr << "[DEBUG] " << "reg:   SDiv(imm, imm)\n";
    };

%%

/* burm_trace - print trace message for matching p */
static void burm_trace(NODEPTR p, int eruleno, COST cost) {
	if (shouldTrace)
		std::cerr << "[DEBUG] " << "0x" << p << " matched " << burm_string[eruleno] << " = " << eruleno << " with cost " << cost.getCost() << "\n";
}

static void gen(NODEPTR p) {
    if (burm_label(p) == 0)
        std::cerr << "[DEBUG] " << "no cover\n";
    else {
        stmt_action(p->getState(),0);
        if (shouldCover != 0)
            dumpCover(p, 1, 0);
    }
}

// static Tree* tree(int op, Tree* l, Tree* r) {
//     Tree* t = (Tree*) malloc(sizeof *t);

//     t->op = op;
//     t->kids[0] = l; t->kids[1] = r;
//     t->getImmVal() = 0;
//     t->x.state = 0;
//     return t;
// }

#include "llvm/IR/Module.h"
#include "llvm/IR/LLVMContext.h"
// #include "llvm/Support/CommandLine.h"
#include "llvm/Support/SourceMgr.h"
#include "llvm/IRReader/IRReader.h"

using namespace llvm;

void FunctionASM::EmitAssembly()
{
    // FIXME
    std::cout << ".text\n"
              << ".globl " << FuncName << "\n"
              << ".type " << FuncName << ", @function\n"
              << FuncName << ":\n";

    // prologue
    std::cout << "pushq %rbp\n";
    std::cout << "movq %rsp, %rbp\n";
    std::cout << "subq $" << std::to_string(LovalVariableSpaceInBytes) << ", %rsp\n";

    // body
    for(auto* T: ExprTrees)
    {
        if (T->getOp() == /*Label*/69)
            std::cout << T->getLabelString() << ":\n";
        gen(T);
    }

    // epilogue
    std::cout << "movq %rbp, %rsp\n";
    std::cout << "popq %rbp\n";
    std::cout << "retq\n\n";
}

//static cl::opt<std::string>
//InputFilename(cl::Positional, cl::desc("<input bitcode>"), cl::init("-"));

int main(int argc, char *argv[]) {
/*
    Tree t;
    int i;

    for (i = 1; i < argc ; ++i) {
        if (strcmp(argv[i], "--cover") == 0){
            shouldCover = 1;
        }
        if (strcmp(argv[i], "--trace") == 0){
            shouldTrace = 1;
        }
    }
    printf("a = 1 - 2 + 0;\n");
    t = tree(Add,
        tree(Sub,
            (t = tree(IMM, nullptr, nullptr), t->getImmVal() = 1, t),
            (t = tree(IMM, nullptr, nullptr), t->getImmVal() = 2, t)),
        (t = tree(IMM, nullptr, nullptr), t->getImmVal() = 0, t)
    );
    gen(t);
*/

    // parse arguments from command line
    // cl::ParseCommandLineOptions(argc, argv, "llc-olive\n");

    // prepare llvm context to read bitcode file
    LLVMContext Context;
    SMDiagnostic Error;
    std::unique_ptr<Module> M = parseIRFile(/*InputFilename*/argv[1], Error, Context);

    ExprTreeBuilder Builder(M->getDataLayout());
    Builder.visit(*M);
    for(auto& F: Builder.Functions)
    {
        F.EmitAssembly();
    }
    return 0;
}
