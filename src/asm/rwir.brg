%{
#include "helper.h"
%}

# TODO: autogen from llvm/include/llvm/IR/Instruction.def

%term Undef         =  0

# Terminator Instructions
%term Ret           =  1
%term Br            =  2
%term Switch        =  3
%term IndirectBr    =  4
%term Invoke        =  5
%term Resume        =  6
%term Unreachable   =  7
%term CleanupRet    =  8
%term CatchRet      =  9
%term CatchSwitch   = 10
%term CallBr        = 11

# Standard unary operators
%term FNeg          = 12

# Standard binary operators
%term Add  = 13
%term FAdd = 14
%term Sub  = 15
%term FSub = 16
%term Mul  = 17
%term FMul = 18
%term UDiv = 19
%term SDiv = 20
%term FDiv = 21
%term URem = 22
%term SRem = 23
%term FRem = 24

# Logical operators (integer operands)
%term Shl  = 25
%term LShr = 26
%term AShr = 27
%term And  = 28
%term Or   = 29
%term Xor  = 30

# Memory operators
%term Alloca        = 31
%term Load          = 32
%term Store         = 33
%term GetElementPtr = 34
%term Fence         = 35
%term AtomicCmpXchg = 36
%term AtomicRMW     = 37

# Cast operators
%term Trunc         = 38
%term ZExt          = 39
%term SExt          = 40
%term FPToUI        = 41
%term FPToSI        = 42
%term UIToFP        = 43
%term SIToFP        = 44
%term FPTrunc       = 45
%term FPExt         = 46
%term PtrToInt      = 47
%term IntToPtr      = 48
%term BitCast       = 49
%term AddrSpaceCast = 50

# FUNCLETPAD
%term CleanupPad    = 51
%term CatchPad      = 52

# Other operators
%term ICmp              = 53
%term FCmp              = 54
%term PHI               = 55
%term Call              = 56
%term Select            = 57
%term UserOp1           = 58
%term UserOp2           = 59
%term VAArg             = 60
%term ExtractElement    = 61
%term InsertElement     = 62
%term ShuffleVector     = 63
%term ExtractValue      = 64
%term InsertValue       = 65
%term LandingPad        = 66
%term Freeze            = 67

%term Const            = 68
%term Label            = 69
%term Args             = 70
%term Reg              = 71

%declare<void> stmt<AsmCodeGeneratorPtr AsmGen>;
%declare<void> reg<AsmCodeGeneratorPtr AsmGen>;
%declare<void> imm<AsmCodeGeneratorPtr AsmGen>;
%declare<void> mem<AsmCodeGeneratorPtr AsmGen>;
%declare<void> label<AsmCodeGeneratorPtr AsmGen>;
%declare<void> cond<AsmCodeGeneratorPtr AsmGen>;
%declare<void> arg<AsmCodeGeneratorPtr AsmGen, unsigned argNo>;
%declare<void> args<AsmCodeGeneratorPtr AsmGen, unsigned argNo>;

%%

label: Label { $cost[0].cost = 0; } = { };

imm: Const { $cost[0].cost = 0; } = { };

reg: Reg { $cost[0].cost = 0; } = { };

mem: Alloca(imm) { $cost[0].cost = 0; } = { };

reg: Load(mem) { $cost[0].cost = $cost[2].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Load(mem)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $0->setRegLoc(true);
    AsmGen->EmitMov($2->getMemLoc(), $0->getRegLocString());
};

reg: Load(reg) { $cost[0].cost = $cost[2].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Load(reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $0->setRegLoc(true);
    AsmGen->EmitMov('(' + $2->getRegLocString() + ')',
                       $0->getRegLocString());
};

stmt: reg { $cost[0].cost = $cost[1].cost; }
= {
    std::cerr << "[DEBUG] " << "stmt:    reg\n";
    // if ($0->isActionExecuted())
    //     return;
    // $0->setActionExecuted();
    $action[1](AsmGen);
};

stmt: Ret(reg) { $cost[0].cost = $cost[2].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt:    Ret(reg)\n";
    $action[2](AsmGen);
    AsmGen->EmitMov($2->getRegLocString(), "%rax");
};

stmt: Ret(imm) { $cost[0].cost = $cost[2].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt:    Ret(imm)\n";
    $action[2](AsmGen);
    AsmGen->EmitMov($2->getImmVal(), "%rax");
};

stmt: Store(reg, mem) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt:   Store(reg, mem)\n";
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitMov($2->getRegLocString(), $3->getMemLoc());
};

stmt: Store(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt:   Store(reg, reg)\n";
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitMov($2->getRegLocString(),
                    '(' + $3->getRegLocString() + ')');
};

stmt: Store(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt:   Store(imm, reg)\n";
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitMov($2->getImmVal(),
                    '(' + $3->getRegLocString() + ')');
};

stmt: Store(imm, mem) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt:   Store(imm, mem)\n";
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitMov($2->getImmVal(), $3->getMemLoc());
};

stmt: Store(mem, mem) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt:   Store(mem, mem)\n";
    $action[2](AsmGen);
    $action[3](AsmGen);
    auto AvailReg = RA->getAvailableRegister();
    const char* AvailRegStr = convertRegisterToString(AvailReg);
    AsmGen->EmitLea($2->getMemLoc(), AvailRegStr);
    AsmGen->EmitMov(AvailRegStr, $3->getMemLoc());
};

stmt: Store(label, mem) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt:   Store(label, mem)\n";
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitMov($2->getLabelStringAsConstant(), $3->getMemLoc());
};

cond: ICmp(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "cond: ICmp(reg, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitCmp($3->getRegLocString(), $2->getRegLocString());
};

cond: ICmp(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "cond: ICmp(reg, imm)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitCmp($3->getImmVal(), $2->getRegLocString());
};

cond: ICmp(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "cond: ICmp(imm, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    auto AvailReg = RA->getAvailableRegister();
    const char* AvailRegStr = convertRegisterToString(AvailReg);
    AsmGen->EmitMov($2->getImmVal(), AvailRegStr);
    AsmGen->EmitCmp($3->getRegLocString(), AvailRegStr);
};

# Conditional Branch
stmt: Br(cond, label, label)
{ $cost[0].cost = $cost[2].cost + $cost[3].cost + $cost[4].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt: Br(cond, label, label)\n";
    $action[2](AsmGen);
    std::string JmpTrue, JmpFalse;
    auto *CI = llvm::cast<llvm::CmpInst>($2->getInstruction());
    switch (CI->getPredicate()) {
    case llvm::CmpInst::Predicate::ICMP_EQ:
        JmpTrue = "je";
        JmpFalse = "jne";
        break;
    case llvm::CmpInst::Predicate::ICMP_NE:
        JmpTrue = "jne";
        JmpFalse = "je";
        break;
    case llvm::CmpInst::Predicate::ICMP_SGT:
        JmpTrue = "jg";
        JmpFalse = "jle";
        break;
    default:
        llvm_unreachable("unexpected CmpInst!\n");
    }
    auto *BI = llvm::cast<llvm::BranchInst>($1->getInstruction());
    llvm::BasicBlock* NextBB = BI->getParent()->getNextNode();
    if (NextBB == BI->getSuccessor(0)) {
        AsmGen->EmitJmp(JmpFalse, $4->getLabelStringAsLabel());
    }
    else if (NextBB == BI->getSuccessor(1)) {
        AsmGen->EmitJmp(JmpTrue, $3->getLabelStringAsLabel());
    }
    else {
        AsmGen->EmitJmp(JmpTrue, $3->getLabelStringAsLabel());
        AsmGen->EmitJmp(JmpFalse, $4->getLabelStringAsLabel());
    }
};

# Unconditional Branch
stmt: Br(label, Undef, Undef) { $cost[0].cost = $cost[2].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "stmt: Br(label)\n";
    auto *BI = llvm::cast<llvm::BranchInst>($1->getInstruction());
    llvm::BasicBlock* NextBB = BI->getParent()->getNextNode();
    if (NextBB != BI->getSuccessor(0)) {
        AsmGen->EmitJmp("jmp", $2->getLabelStringAsLabel());
    }
};

reg: Add(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Add(reg, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitAdd($2->getRegLocString(), $3->getRegLocString());
    $0->setRegLoc(false, $3->getRegLoc());
};

reg: Add(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Add(reg, imm)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitAdd($3->getImmVal(), $2->getRegLocString());
    $0->setRegLoc(false, $2->getRegLoc());
};

reg: Add(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Add(imm, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitAdd($2->getImmVal(), $3->getRegLocString());
    $0->setRegLoc(false, $3->getRegLoc());
};

reg: Add(imm, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Add(imm, imm)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    llvm_unreachable("unexpected `reg: Add(imm, imm)!`\n");
};

reg: Sub(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Sub(reg, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitSub($3->getRegLocString(), $2->getRegLocString());
    $0->setRegLoc(false, $3->getRegLoc());
};

reg: Sub(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Sub(reg, imm)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitSub($3->getImmVal(), $2->getRegLocString());
    $0->setRegLoc(false, $2->getRegLoc());
};

reg: Sub(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
= {
    std::cerr << "[DEBUG] " << "reg:   Sub(imm, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    $0->setRegLoc(true);
    AsmGen->EmitMov($2->getImmVal(), $0->getRegLocString());
    AsmGen->EmitSub($3->getRegLocString(), $0->getRegLocString());
};

reg: Sub(imm, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Sub(imm, imm)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    llvm_unreachable("unexpected `reg: Sub(imm, imm)!`\n");
};

reg: Mul(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Mul(reg, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitImul($2->getRegLocString(), $3->getRegLocString());
    $0->setRegLoc(false, $3->getRegLoc());
};

reg: Mul(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Mul(reg, imm)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitImul($3->getImmVal(), $2->getRegLocString());
    $0->setRegLoc(false, $2->getRegLoc());
};

reg: Mul(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Mul(imm, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitImul($2->getImmVal(), $3->getRegLocString());
    $0->setRegLoc(false, $3->getRegLoc());
};

reg: Mul(imm, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:   Mul(imm, imm)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    llvm_unreachable("unexpected `reg: Mul(imm, imm)!`\n");
};

reg: SDiv(reg, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
= {
    std::cerr << "[DEBUG] " << "reg:   SDiv(reg, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitMov($2->getRegLocString(), "%rax");
    AsmGen->EmitCqto();
    AsmGen->EmitIdiv($3->getRegLocString());
    $0->setRegLoc(false, Register::RAX);
};

reg: SDiv(reg, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
= {
    std::cerr << "[DEBUG] " << "reg:   SDiv(reg, imm)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    $0->setRegLoc(true);
    AsmGen->EmitMov($2->getRegLocString(), "%rax");
    AsmGen->EmitCqto();
    AsmGen->EmitMov($3->getImmVal(), $0->getRegLocString());
    AsmGen->EmitIdiv($0->getRegLocString());
    AsmGen->EmitMov("%rax", $0->getRegLocString());
};

reg: SDiv(imm, reg) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 2; }
= {
    std::cerr << "[DEBUG] " << "reg:   SDiv(imm, reg)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    AsmGen->EmitMov($2->getImmVal(), "%rax");
    AsmGen->EmitCqto();
    AsmGen->EmitIdiv($3->getRegLocString());
    $0->setRegLoc(false, Register::RAX);
};

reg: SDiv(imm, imm) { $cost[0].cost = $cost[2].cost + $cost[3].cost + 3; }
= {
    std::cerr << "[DEBUG] " << "reg:   SDiv(imm, imm)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen);
    llvm_unreachable("unexpected `reg: SDiv(imm, imm)!`\n");
    $0->setRegLoc(true);
    AsmGen->EmitMov($3->getImmVal(), "%rax");
    AsmGen->EmitCqto();
    AsmGen->EmitMov($2->getImmVal(), $0->getRegLocString());
    AsmGen->EmitIdiv($0->getRegLocString());
    AsmGen->EmitMov("%rax", $0->getRegLocString());
};

arg: reg { $cost[0].cost = $cost[1].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "arg:  reg\n";
    $action[1](AsmGen);
    if (argNo < 6) {
        AsmGen->EmitMov($1->getRegLocString(),
                           convertRegisterToString(ArgRegs[argNo]));
    } else {
        AsmGen->EmitMov($1->getRegLocString(),
                           std::to_string(8 * (argNo - 6)) + "(%rsp)");
    }
};

arg: imm { $cost[0].cost = $cost[1].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "arg:  imm\n";
    $action[1](AsmGen);
    if (argNo < 6) {
        AsmGen->EmitMov($1->getImmVal(),
                           convertRegisterToString(ArgRegs[argNo]));
    } else {
        AsmGen->EmitMov($1->getImmVal(),
                           std::to_string(8 * (argNo - 6)) + "(%rsp)");
    }
};

arg: mem { $cost[0].cost = $cost[1].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "arg:  mem\n";
    $action[1](AsmGen);
    if (argNo < 6) {
        AsmGen->EmitLea($1->getMemLoc(),
                           convertRegisterToString(ArgRegs[argNo]));
    } else {
        AsmGen->EmitMov($1->getMemLoc(),
                           std::to_string(8 * (argNo - 6)) + "(%rsp)");
    }
};

arg: label { $cost[0].cost = $cost[1].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "arg:  mem\n";
    $action[1](AsmGen);
    if (argNo < 6) {
        AsmGen->EmitMov($1->getLabelStringAsConstant(),
                           convertRegisterToString(ArgRegs[argNo]));
    } else {
        AsmGen->EmitMov($1->getLabelStringAsConstant(),
                           std::to_string(8 * (argNo - 6)) + "(%rsp)");
    }
};

args: Args(Undef, Undef) { $cost[0].cost = 0; }
= {
    std::cerr << "[DEBUG] " << "args:   ARGS(Undef, Undef)\n";
};

args: Args(arg, args)  { $cost[0].cost = $cost[2].cost + $cost[3].cost; }
= {
    std::cerr << "[DEBUG] " << "args:   ARGS(value, args)\n";
    $action[2](AsmGen, argNo);
    $action[3](AsmGen, argNo+1);
};

# Direct Call
reg: Call(label, args) { $cost[0].cost = $cost[2].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:    Call(label, args)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen, 0);
    auto* CB = llvm::cast<llvm::CallBase>($1->getInstruction());
    std::string Callee = $2->getLabelStringAsLabel();
    if (Callee == "printf" || Callee == "scanf") {
        AsmGen->EmitXor("%rax", "%rax");
    }
    AsmGen->EmitCall($2->getLabelStringAsLabel());
    $0->setRegLoc(false, Register::RAX);
};

# Indirect Call
reg: Call(reg, args) { $cost[0].cost = $cost[2].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:    Call(reg, args)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen, 0);
    AsmGen->EmitCall("*" + $2->getRegLocString());
    $0->setRegLoc(false, Register::RAX);
};

# Indirect call
reg: Call(mem, args) { $cost[0].cost = $cost[2].cost + 1; }
= {
    std::cerr << "[DEBUG] " << "reg:    Call(mem, args)\n";
    if ($0->isActionExecuted())
        return;
    $0->setActionExecuted();
    $action[2](AsmGen);
    $action[3](AsmGen, 0);
    AsmGen->EmitCall("*" + $2->getMemLoc());
    $0->setRegLoc(false, Register::RAX);
};

%%

/* burm_trace - print trace message for matching p */
static void burm_trace(NODEPTR p, int eruleno, COST cost) { }

static void gen(NODEPTR p, AsmCodeGenerator *AsmGen) {
    if (burm_label(p) == 0)
        std::cerr << "[DEBUG] " << "no cover\n";
    else {
        stmt_action(p->getState(), AsmGen);
    }
}

#include "llvm/IR/Module.h"
#include "llvm/IR/LLVMContext.h"
// #include "llvm/Support/CommandLine.h"
#include "llvm/Support/SourceMgr.h"
#include "llvm/IRReader/IRReader.h"

using namespace llvm;

void printDebugTree(Node *p, int indent=0) {
    if(p != nullptr) {
        if (indent) std::cerr << "|";
        int i = 0;
        for (; i < indent-4; ++i) std::cerr << " ";
        if (indent-4 > 0) std::cerr << "|";
        for (; i < indent; ++i) std::cerr << "-";
        std::cerr << "+ op:" << p->getOp() << ", Kind:" << p->getNodeKind() << "\n";

        for(auto *kid: p->Kids)
        {
            printDebugTree(kid, (indent+4));
        }
    }
}

void AsmCodeGenerator::EmitFunction(AsmFunction &F)
{
    EmitFunctionDeclaration(F);

    EmitFunctionPrologue(F);

    // body
    for (auto* T: F.ExprTrees)
    {
        printDebugTree(T);
        if (T->getOp() == /*Label*/69)
            Out << T->getLabelStringAsLabel() << ":\n";
        gen(T, this);
    }

    EmitFunctionEpilogue(F);
}

static cl::opt<std::string>
InputFilename(cl::Positional, cl::desc("<input bitcode>"), cl::init("-"));

int main(int argc, char *argv[]) {
    // parse arguments from command line
    cl::ParseCommandLineOptions(argc, argv, "llc-olive\n");

    // prepare llvm context to read bitcode file
    LLVMContext Context;
    SMDiagnostic Error;
    std::unique_ptr<Module> M = parseIRFile(InputFilename, Error, Context);

    ExprTreeBuilder Builder(M->getDataLayout());
    Builder.visit(*M);

    AsmCodeGenerator AsmGen(Builder.Functions, Builder.ConstantStrings);
    AsmGen.EmitAssembly();

    return 0;
}
